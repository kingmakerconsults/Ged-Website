'use strict';

class AbortError extends Error {
  constructor(message) {
    super(message);
    this.name = 'AbortError';
  }
}

function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function pRetry(fn, options = {}) {
  if (typeof fn !== 'function') {
    throw new TypeError('pRetry requires a function');
  }

  const retries = Number.isInteger(options.retries) ? options.retries : 0;
  const minTimeout = typeof options.minTimeout === 'number' ? Math.max(0, options.minTimeout) : 0;
  const maxTimeout = typeof options.maxTimeout === 'number' ? Math.max(minTimeout, options.maxTimeout) : undefined;
  const onFailedAttempt = typeof options.onFailedAttempt === 'function' ? options.onFailedAttempt : null;

  let attempt = 0;
  let lastError;

  while (attempt <= retries) {
    try {
      return await fn(attempt);
    } catch (error) {
      if (error instanceof AbortError) {
        throw error;
      }
      lastError = error;

      if (onFailedAttempt) {
        await onFailedAttempt({
          attemptNumber: attempt + 1,
          retriesLeft: Math.max(0, retries - attempt),
          error
        });
      }

      if (attempt === retries) {
        throw error;
      }

      const exponential = minTimeout ? minTimeout * Math.pow(2, attempt) : 0;
      const waitTime = maxTimeout === undefined
        ? (exponential || minTimeout)
        : Math.min(maxTimeout, Math.max(minTimeout, exponential || minTimeout));

      if (waitTime > 0) {
        await delay(waitTime);
      }
    }
    attempt += 1;
  }

  throw lastError || new Error('pRetry failed without error.');
}

pRetry.AbortError = AbortError;
module.exports = pRetry;
module.exports.default = pRetry;
module.exports.AbortError = AbortError;
