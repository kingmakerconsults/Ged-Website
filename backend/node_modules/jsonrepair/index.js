'use strict';

function tryParse(text) {
  try {
    JSON.parse(text);
    return { ok: true, value: text };
  } catch (error) {
    return { ok: false, error };
  }
}

function normalizeTrailingCommas(text) {
  return text.replace(/,\s*([}\]])/g, '$1');
}

function convertSingleQuotes(text) {
  return text.replace(/'(?:[^'\\]|\\.)*'/g, (match) => {
    const inner = match.slice(1, -1).replace(/\\"/g, '"').replace(/"/g, '\\"');
    return `"${inner}"`;
  });
}

function quoteKeys(text) {
  return text.replace(/([,{]\s*)([A-Za-z_][A-Za-z0-9_]*)(\s*:)/g, (m, prefix, key, suffix) => {
    return `${prefix}"${key}"${suffix}`;
  });
}

function jsonrepair(text) {
  if (typeof text !== 'string') {
    throw new TypeError('jsonrepair input must be a string');
  }

  let attempt = tryParse(text);
  if (attempt.ok) {
    return attempt.value;
  }
  let lastError = attempt.error;

  const withoutTrailing = normalizeTrailingCommas(text);
  attempt = tryParse(withoutTrailing);
  if (attempt.ok) {
    return attempt.value;
  }
  lastError = attempt.error;

  const withDoubleQuotes = convertSingleQuotes(withoutTrailing);
  attempt = tryParse(withDoubleQuotes);
  if (attempt.ok) {
    return attempt.value;
  }
  lastError = attempt.error;

  const withQuotedKeys = quoteKeys(withDoubleQuotes);
  attempt = tryParse(withQuotedKeys);
  if (attempt.ok) {
    return attempt.value;
  }
  lastError = attempt.error;

  throw lastError;
}

module.exports = { jsonrepair };
