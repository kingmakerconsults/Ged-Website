import React, { useEffect, useState, useMemo } from 'react';
import { normalizeImageUrl } from '../../utils/normalizeImageUrl.js';

const ISSUE_DEFS = {
  MATH_LATEX_UNBALANCED: {
    severity: 'BLOCKER',
    label: 'MATH_LATEX_UNBALANCED',
    description: 'Unbalanced \\( ... \\) or \\[ ... \\] delimiters detected.',
    confidence: 'high',
  },
  MATH_LATEX_DOLLAR_DELIMITER: {
    severity: 'MAJOR',
    label: 'MATH_LATEX_DOLLAR_DELIMITER',
    description: 'Found $...$ delimiters; platform expects \\( ... \\).',
    confidence: 'low',
  },
  MATH_LATEX_DOLLAR_UNBALANCED: {
    severity: 'BLOCKER',
    label: 'MATH_LATEX_DOLLAR_UNBALANCED',
    description: 'Odd/unbalanced $ delimiters detected.',
    confidence: 'high',
  },
  MATH_LATEX_BRACE_UNBALANCED: {
    severity: 'BLOCKER',
    label: 'MATH_LATEX_BRACE_UNBALANCED',
    description: 'Unmatched { } braces inside a LaTeX expression.',
    confidence: 'high',
  },
  MATH_COMMAND_OUTSIDE_DELIMITERS: {
    severity: 'MAJOR',
    label: 'MATH_COMMAND_OUTSIDE_DELIMITERS',
    description: 'LaTeX command appears outside math delimiters.',
    confidence: 'medium',
  },
  MATH_PLAIN_FRACTION_IN_MATH: {
    severity: 'MAJOR',
    label: 'MATH_PLAIN_FRACTION_IN_MATH',
    description: 'Plain-text fraction detected inside math context.',
    confidence: 'low',
  },
  MISSING_PROMPT: {
    severity: 'BLOCKER',
    label: 'MISSING_PROMPT',
    description: 'Question prompt is empty, placeholder, or truncated.',
    confidence: 'high',
  },
  MISSING_STIMULUS_PASSAGE: {
    severity: 'BLOCKER',
    label: 'MISSING_STIMULUS_PASSAGE',
    description: 'Passage-based question is missing its passage.',
    confidence: 'high',
  },
  MISSING_STIMULUS_TABLE: {
    severity: 'BLOCKER',
    label: 'MISSING_STIMULUS_TABLE',
    description: 'Table-based question references a table that is missing.',
    confidence: 'high',
  },
  MISSING_STIMULUS_IMAGE: {
    severity: 'BLOCKER',
    label: 'MISSING_STIMULUS_IMAGE',
    description: 'Image-based question is missing a resolvable image path.',
    confidence: 'high',
  },
  IMAGE_PATH_INVALID: {
    severity: 'MAJOR',
    label: 'IMAGE_PATH_INVALID',
    description: 'Image path appears malformed or not resolvable.',
    confidence: 'medium',
  },
  TABLE_HTML_BROKEN: {
    severity: 'BLOCKER',
    label: 'TABLE_HTML_BROKEN',
    description: 'HTML table markup is incomplete or malformed.',
    confidence: 'high',
  },
  TABLE_ROW_MISMATCH: {
    severity: 'BLOCKER',
    label: 'TABLE_ROW_MISMATCH',
    description: 'Table rows have inconsistent column counts.',
    confidence: 'high',
  },
  TABLE_PIPE_MISMATCH: {
    severity: 'BLOCKER',
    label: 'TABLE_PIPE_MISMATCH',
    description: 'Pipe-table has inconsistent column counts.',
    confidence: 'high',
  },
  FILLER_MISMATCH: {
    severity: 'MAJOR',
    label: 'FILLER_MISMATCH',
    description: 'Question/answer mismatch suggests filler or generic options.',
    confidence: 'medium',
  },
  REGRESSION: {
    severity: 'MAJOR',
    label: 'REGRESSION',
    description: 'Previously fixed issue appears again after reload.',
    confidence: 'high',
  },
};

const ISSUE_WHY = {
  MATH_LATEX_UNBALANCED:
    'Detected opening \\( or \\[ without a matching close.',
  MATH_LATEX_DOLLAR_DELIMITER:
    'Detected $...$ delimiter usage where \\( ... \\) is expected.',
  MATH_LATEX_DOLLAR_UNBALANCED: 'Detected an odd count of $ delimiters.',
  MATH_LATEX_BRACE_UNBALANCED: 'Detected unbalanced { } braces in LaTeX.',
  MATH_COMMAND_OUTSIDE_DELIMITERS:
    'LaTeX command appears outside a math delimiter pair.',
  MATH_PLAIN_FRACTION_IN_MATH:
    'Detected plain 3/4-style fraction inside math expression.',
  MISSING_PROMPT: 'Question text is empty, placeholder-like, or truncated.',
  MISSING_STIMULUS_PASSAGE: 'Question expects a passage but none is present.',
  MISSING_STIMULUS_TABLE: 'Question references a table but none is present.',
  MISSING_STIMULUS_IMAGE:
    'Question references an image but none is resolvable.',
  IMAGE_PATH_INVALID: 'Image URL is missing or malformed for display.',
  TABLE_HTML_BROKEN: 'Table markup is missing required tags.',
  TABLE_ROW_MISMATCH: 'Table rows do not share a consistent column count.',
  TABLE_PIPE_MISMATCH: 'Pipe-table rows have inconsistent pipe counts.',
  FILLER_MISMATCH: 'Low keyword overlap between stem and answer options.',
  REGRESSION: 'A previously fixed issue was detected again.',
};

// Non-goals: no auto-fixing, no AI rewriting, no silent normalization, no bulk content changes.

const PLACEHOLDER_PATTERNS = [
  /\bplaceholder\b/i,
  /\blorem\s+ipsum\b/i,
  /\btbd\b/i,
  /\bto\s*be\s*determined\b/i,
  /\bcoming\s+soon\b/i,
  /\bwrite\s+question\b/i,
  /\binsert\s+question\b/i,
  /\bsample\s+question\b/i,
  /\bfill\s+in\s+later\b/i,
  /\bautogenerated?\b/i,
  /\btemplate\b/i,
  /_{3,}/,
  /\[\s*\.\.\.\s*\]/,
  /\{\s*\.\.\.\s*\}/,
];

const STOPWORDS = new Set([
  'the',
  'a',
  'an',
  'and',
  'or',
  'but',
  'if',
  'then',
  'else',
  'of',
  'to',
  'in',
  'on',
  'for',
  'with',
  'as',
  'by',
  'at',
  'from',
  'is',
  'are',
  'was',
  'were',
  'be',
  'being',
  'been',
  'this',
  'that',
  'these',
  'those',
  'which',
  'what',
  'who',
  'whom',
  'whose',
  'why',
  'how',
  'when',
  'where',
  'not',
  'no',
  'yes',
  'do',
  'does',
  'did',
  'can',
  'could',
  'would',
  'should',
  'will',
  'may',
  'might',
]);

const GENERIC_OPTIONS = new Set([
  'all of the above',
  'none of the above',
  'both a and b',
  'both b and c',
  'both a and c',
  'neither a nor b',
  'neither b nor c',
  'neither a nor c',
  'true',
  'false',
  'cannot be determined',
  'not enough information',
  'insufficient information',
  'unknown',
]);

function stripHtml(value) {
  if (typeof value !== 'string') return '';
  return value.replace(/<[^>]*>/g, ' ');
}

function normalizeText(value) {
  return stripHtml(value).replace(/\s+/g, ' ').trim();
}

function tokenize(value) {
  const clean = normalizeText(value).toLowerCase();
  if (!clean) return [];
  return clean
    .replace(/[^a-z0-9\s]/g, ' ')
    .split(/\s+/)
    .filter((t) => t.length > 2 && !STOPWORDS.has(t));
}

function countNumericTokens(value) {
  if (typeof value !== 'string') return 0;
  const matches = value.match(/\b\d+(?:\.\d+)?\b/g);
  return matches ? matches.length : 0;
}

function isPlaceholderText(value) {
  const text = normalizeText(value);
  if (!text) return true;
  if (text.length < 3) return true;
  if (/\.\.\.$/.test(text)) return true;
  return PLACEHOLDER_PATTERNS.some((p) => p.test(text));
}

function hasTableMarkup(value) {
  if (typeof value !== 'string') return false;
  return /<table[\s\S]*?>|\|.+\|/.test(value);
}

function referencesTableContext(text) {
  if (typeof text !== 'string') return false;
  const lower = text.toLowerCase();
  const ignorePhrases = [
    'kitchen table',
    'dining table',
    'coffee table',
    'tablecloth',
    'table manners',
    'table tennis',
    'table for two',
  ];
  if (ignorePhrases.some((p) => lower.includes(p))) return false;
  const explicit =
    /(table (below|above|shown|shows)|table\s*\d+|see (the )?table|in the table|data table|frequency table|reference table)/i;
  return explicit.test(text);
}

function extractPipeTableRows(text) {
  if (typeof text !== 'string') return [];
  return text
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.includes('|') && line.split('|').length > 2);
}

function countPipeColumns(line) {
  const trimmed = String(line || '').trim();
  if (!trimmed.includes('|')) return 0;
  let parts = trimmed.split('|');
  if (parts[0].trim() === '') parts = parts.slice(1);
  if (parts[parts.length - 1].trim() === '') parts = parts.slice(0, -1);
  return parts.length;
}

function getHtmlTableRows(html) {
  if (typeof html !== 'string') return [];
  const tables = html.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi) || [];
  return tables.map((table) => {
    const rows = [];
    const rowMatches = table.match(/<tr[\s\S]*?>[\s\S]*?<\/tr>/gi) || [];
    rowMatches.forEach((row) => {
      const cells = row.match(/<t[dh][\s\S]*?>/gi) || [];
      rows.push(cells.length);
    });
    return rows;
  });
}

function hasUnbalancedDelimiters(text, openToken, closeToken) {
  if (typeof text !== 'string') return false;
  const tokens = [];
  const regex = new RegExp(`(${openToken}|${closeToken})`, 'g');
  let match;
  while ((match = regex.exec(text))) {
    tokens.push({ value: match[0], index: match.index });
  }
  let balance = 0;
  for (const t of tokens) {
    if (t.value === openToken) balance++;
    if (t.value === closeToken) balance--;
    if (balance < 0) return true;
  }
  return balance !== 0;
}

function findUnescapedDollarCount(text) {
  if (typeof text !== 'string') return 0;
  let count = 0;
  for (let i = 0; i < text.length; i++) {
    if (text[i] === '$' && text[i - 1] !== '\\') {
      // Ignore currency-style $ followed by a number (e.g., $400, $0.75)
      let j = i + 1;
      while (j < text.length && text[j] === ' ') j++;
      if (j < text.length && /\d/.test(text[j])) {
        continue;
      }
      if (text[i + 1] === '$') {
        i++;
        continue;
      }
      count++;
    }
  }
  return count;
}

function hasUnbalancedBraces(latex) {
  if (typeof latex !== 'string') return false;
  let balance = 0;
  for (let i = 0; i < latex.length; i++) {
    const ch = latex[i];
    if (ch === '{' && latex[i - 1] !== '\\') balance++;
    if (ch === '}' && latex[i - 1] !== '\\') balance--;
    if (balance < 0) return true;
  }
  return balance !== 0;
}

function containsLatexCommandOutsideMath(text) {
  if (typeof text !== 'string') return false;
  const commands =
    /(\\frac|\\sqrt|\\times|\\cdot|\\pi|\\theta|\\left|\\right|\\begin|\\end|\\sum|\\int|\\approx|\\neq|\\leq|\\geq)/g;
  return commands.test(text);
}

function isVocabularyContext(question, questionText) {
  const subject = String(question?.subject || '').toLowerCase();
  if (!subject.includes('language')) return false;
  const category = String(question?.category || '').toLowerCase();
  const quizTitle = String(question?.quizTitle || '').toLowerCase();
  if (category.includes('vocabulary') || quizTitle.includes('vocabulary')) {
    return true;
  }
  const text = String(questionText || '').toLowerCase();
  return /\b(what does|most nearly mean|meaning of|definition of|word|phrase)\b/.test(
    text
  );
}

function extractMathSegments(text) {
  if (typeof text !== 'string' || text.length === 0) {
    return [];
  }

  const segments = [];
  let buffer = '';

  const flushText = () => {
    if (buffer) {
      segments.push({ type: 'text', value: buffer });
      buffer = '';
    }
  };

  const isEscapedAt = (s, idx) => {
    let backslashes = 0;
    for (let k = idx - 1; k >= 0 && s[k] === '\\'; k--) backslashes++;
    return backslashes % 2 === 1;
  };

  let i = 0;
  while (i < text.length) {
    // escaped dollar sign: \$
    if (text[i] === '\\' && text[i + 1] === '$') {
      buffer += '$';
      i += 2;
      continue;
    }

    // \( ... \) inline math
    if (text[i] === '\\' && text[i + 1] === '(') {
      const close = text.indexOf('\\)', i + 2);
      if (close !== -1) {
        flushText();
        const raw = text.slice(i, close + 2);
        const body = text.slice(i + 2, close);
        segments.push({ type: 'math', raw, value: body, displayMode: false });
        i = close + 2;
        continue;
      }
    }

    // \[ ... \] display math
    if (text[i] === '\\' && text[i + 1] === '[') {
      const close = text.indexOf('\\]', i + 2);
      if (close !== -1) {
        flushText();
        const raw = text.slice(i, close + 2);
        const body = text.slice(i + 2, close);
        segments.push({ type: 'math', raw, value: body, displayMode: true });
        i = close + 2;
        continue;
      }
    }

    // $$ ... $$ display math
    if (text[i] === '$' && text[i + 1] === '$' && !isEscapedAt(text, i)) {
      const close = text.indexOf('$$', i + 2);
      if (close !== -1) {
        flushText();
        const raw = text.slice(i, close + 2);
        const body = text.slice(i + 2, close);
        segments.push({ type: 'math', raw, value: body, displayMode: true });
        i = close + 2;
        continue;
      }
    }

    // $ ... $ inline math
    if (text[i] === '$' && !isEscapedAt(text, i) && text[i + 1] !== '$') {
      let j = i + 1;
      while (j < text.length) {
        if (text[j] === '$' && !isEscapedAt(text, j) && text[j + 1] !== '$') {
          break;
        }
        j++;
      }
      if (j < text.length && text[j] === '$') {
        flushText();
        const raw = text.slice(i, j + 1);
        const body = text.slice(i + 1, j);
        segments.push({ type: 'math', raw, value: body, displayMode: false });
        i = j + 1;
        continue;
      }
    }

    buffer += text[i];
    i += 1;
  }

  flushText();
  return segments;
}

// Sanitize and render text with KaTeX for math formulas
function renderTextWithKatex(text) {
  if (typeof text !== 'string') return '';

  // First apply sanitization to fix broken LaTeX
  let sanitized = text;
  if (typeof window !== 'undefined' && window.TextSanitizer) {
    if (typeof window.TextSanitizer.fixAllMathInText === 'function') {
      sanitized = window.TextSanitizer.fixAllMathInText(text);
    } else if (
      typeof window.TextSanitizer.addMissingBackslashesInMath === 'function'
    ) {
      sanitized = window.TextSanitizer.addMissingBackslashesInMath(text);
    }
  } else {
    // Fallback: basic LaTeX corruption repair
    sanitized = sanitized.replace(/(?:\^|\f)rac\{/gi, '\\frac{');
    sanitized = sanitized.replace(/(?:\^|\f)sqrt\{/gi, '\\sqrt{');
  }

  // Extract math and non-math segments
  const segments = extractMathSegments(sanitized);
  const parts = [];

  const katexImpl =
    typeof globalThis !== 'undefined' && globalThis.katex
      ? globalThis.katex
      : typeof window !== 'undefined' && window.katex
        ? window.katex
        : null;

  for (const seg of segments.length
    ? segments
    : [{ type: 'text', value: sanitized }]) {
    if (seg.type !== 'math') {
      // Plain text - just escape HTML
      const escaped = seg.value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
      parts.push(escaped);
      continue;
    }

    const body = (seg.value || '').trim();
    if (!body) {
      parts.push('');
      continue;
    }

    // Render with KaTeX if available
    if (katexImpl && typeof katexImpl.renderToString === 'function') {
      try {
        const html = katexImpl.renderToString(body, {
          throwOnError: false,
          displayMode: Boolean(seg.displayMode),
        });
        parts.push(html);
      } catch (e) {
        // Fallback to plain text if KaTeX fails
        const escaped = body
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
        parts.push(`<span class="math-inline">${escaped}</span>`);
      }
    } else {
      // No KaTeX available - show as plain text
      const escaped = body
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
      parts.push(`<span class="math-inline">${escaped}</span>`);
    }
  }

  return parts.join('');
}

function getQuestionText(question) {
  const content = question?.content || {};
  return (
    question?.question ||
    question?.questionText ||
    content.questionText ||
    content.question ||
    ''
  );
}

function getQuestionPassage(question) {
  const content = question?.content || {};
  return question?.passage || content.passage || '';
}

function getQuestionImage(question) {
  const content = question?.content || {};
  return (
    question?.image ||
    question?.imageUrl ||
    question?.imageURL ||
    question?.graphic ||
    question?.stimulusImage?.src ||
    question?.stimulusImage ||
    content.imageURL ||
    content.image ||
    (typeof question?.stimulus === 'object'
      ? question?.stimulus?.image || question?.stimulus?.src
      : null) ||
    null
  );
}

function getFieldList(question) {
  const fields = [
    { name: 'question', value: getQuestionText(question) },
    { name: 'passage', value: getQuestionPassage(question) },
  ];

  const answerOptions = Array.isArray(question?.answerOptions)
    ? question.answerOptions
    : [];
  answerOptions.forEach((opt, idx) => {
    const text = typeof opt === 'object' ? opt.text : opt;
    const rationale = typeof opt === 'object' ? opt.rationale : undefined;
    fields.push({ name: `answer[${idx}].text`, value: text });
    if (typeof rationale === 'string') {
      fields.push({ name: `answer[${idx}].rationale`, value: rationale });
    }
  });

  return fields;
}

function buildAuditIssues(question) {
  // Safety guardrails: audit-only, no auto-fixes, no AI rewriting, no silent normalization.
  const issues = [];
  const fields = getFieldList(question);
  const questionText = getQuestionText(question);
  const passageText = getQuestionPassage(question);
  const imageRef = getQuestionImage(question);

  const addIssue = (code, context = {}) => {
    const def = ISSUE_DEFS[code] || {};
    const fieldKey = context.field || 'field';
    const patternKey = context.patternKey || 'pattern';
    const issueId = `${code}:${fieldKey}:${patternKey}`;
    issues.push({
      id: issueId,
      code,
      severity: def.severity || 'MAJOR',
      label: def.label || code,
      description: def.description || '',
      confidence: def.confidence || 'medium',
      why: ISSUE_WHY[code] || '',
      ...context,
    });
  };

  // Missing prompt
  if (isPlaceholderText(questionText)) {
    addIssue('MISSING_PROMPT', {
      field: 'question',
      raw: questionText,
      patternKey: 'question-empty',
    });
  }

  // Missing passage stimulus
  if (
    (question?.passage != null || question?.content?.passage != null) &&
    isPlaceholderText(passageText)
  ) {
    addIssue('MISSING_STIMULUS_PASSAGE', {
      field: 'passage',
      raw: passageText,
      patternKey: 'missing-passage',
    });
  }

  // Missing image stimulus
  if (
    (question?.stimulusImage ||
      question?.image ||
      question?.imageUrl ||
      question?.imageURL ||
      question?.graphic ||
      question?.content?.image ||
      question?.content?.imageURL) &&
    !imageRef
  ) {
    addIssue('MISSING_STIMULUS_IMAGE', {
      field: 'image',
      raw: String(imageRef || ''),
      patternKey: 'missing-image',
    });
  }

  if (typeof imageRef === 'string' && imageRef.trim()) {
    const normalized = normalizeImageUrl(imageRef);
    if (!normalized || /undefined|null/i.test(normalized)) {
      addIssue('IMAGE_PATH_INVALID', {
        field: 'image',
        raw: imageRef,
        patternKey: 'invalid-image-path',
      });
    } else if (
      !/(?:\.png|\.jpe?g|\.gif|\.svg|\.webp)(\?|#|$)/i.test(normalized) &&
      !/^data:image\//i.test(normalized)
    ) {
      addIssue('IMAGE_PATH_INVALID', {
        field: 'image',
        raw: imageRef,
        patternKey: 'invalid-image-extension',
      });
    }
  }

  if (
    /<img\b/i.test(passageText || '') &&
    !/src\s*=\s*['"]/i.test(passageText || '')
  ) {
    addIssue('MISSING_STIMULUS_IMAGE', {
      field: 'passage',
      raw: passageText,
      patternKey: 'img-tag-missing-src',
    });
  }

  // Table integrity + missing table stimulus
  const combinedText = [questionText, passageText].filter(Boolean).join('\n');

  const referencesTable =
    referencesTableContext(questionText) || referencesTableContext(passageText);
  const hasTable = hasTableMarkup(combinedText);
  if (referencesTable && !hasTable) {
    addIssue('MISSING_STIMULUS_TABLE', {
      field: 'question/passage',
      raw: combinedText,
      patternKey: 'table-referenced-missing',
    });
  }

  if (typeof combinedText === 'string' && combinedText.includes('<table')) {
    if (!combinedText.includes('</table>')) {
      addIssue('TABLE_HTML_BROKEN', {
        field: 'question/passage',
        raw: combinedText,
        patternKey: 'table-html-missing-close',
      });
    }
    const rowsPerTable = getHtmlTableRows(combinedText);
    rowsPerTable.forEach((rows, idx) => {
      if (rows.length > 1) {
        const expected = rows[0];
        if (rows.some((c) => c !== expected)) {
          addIssue('TABLE_ROW_MISMATCH', {
            field: 'question/passage',
            raw: combinedText,
            patternKey: `table-html-${idx}-cols-${expected}`,
          });
        }
      }
    });
  }

  const pipeRows = extractPipeTableRows(combinedText);
  if (pipeRows.length >= 2) {
    const baseCols = countPipeColumns(pipeRows[0]);
    if (baseCols > 1) {
      const mismatch = pipeRows.some(
        (row) => countPipeColumns(row) !== baseCols
      );
      if (mismatch) {
        addIssue('TABLE_PIPE_MISMATCH', {
          field: 'question/passage',
          raw: combinedText,
          patternKey: `table-pipe-cols-${baseCols}`,
        });
      }
    }
  }

  // Math-specific validation
  fields.forEach((field) => {
    const text = field.value;
    if (typeof text !== 'string' || !text.trim()) return;

    if (
      hasUnbalancedDelimiters(text, '\\(', '\\)') ||
      hasUnbalancedDelimiters(text, '\\[', '\\]')
    ) {
      addIssue('MATH_LATEX_UNBALANCED', {
        field: field.name,
        raw: text,
        patternKey: `${field.name}-latex-unbalanced`,
      });
    }

    const dollarCount = findUnescapedDollarCount(text);
    if (dollarCount % 2 !== 0) {
      addIssue('MATH_LATEX_DOLLAR_UNBALANCED', {
        field: field.name,
        raw: text,
        patternKey: `${field.name}-dollar-odd`,
      });
    }

    const segments = extractMathSegments(text);
    const hasDollarSegments = segments.some((seg) => seg.raw?.startsWith('$'));
    if (hasDollarSegments) {
      addIssue('MATH_LATEX_DOLLAR_DELIMITER', {
        field: field.name,
        raw: text,
        patternKey: `${field.name}-dollar-delim`,
      });
    }

    const textOutsideMath = segments.length
      ? segments
          .filter((seg) => seg.type !== 'math')
          .map((seg) => seg.value)
          .join(' ')
      : text;

    if (containsLatexCommandOutsideMath(textOutsideMath)) {
      addIssue('MATH_COMMAND_OUTSIDE_DELIMITERS', {
        field: field.name,
        raw: textOutsideMath,
        patternKey: `${field.name}-latex-outside`,
      });
    }

    segments
      .filter((seg) => seg.type === 'math')
      .forEach((seg, idx) => {
        if (hasUnbalancedBraces(seg.value)) {
          addIssue('MATH_LATEX_BRACE_UNBALANCED', {
            field: field.name,
            raw: seg.value,
            math: seg.value,
            patternKey: `${field.name}-brace-${idx}`,
          });
        }
        if (/\b\d+\/\d+\b/.test(seg.value) && !/\\frac\b/.test(seg.value)) {
          addIssue('MATH_PLAIN_FRACTION_IN_MATH', {
            field: field.name,
            raw: seg.value,
            math: seg.value,
            patternKey: `${field.name}-plain-frac-${idx}`,
          });
        }
      });
  });

  // Filler / mismatch heuristic
  const answerOptions = Array.isArray(question?.answerOptions)
    ? question.answerOptions
    : [];
  const questionTokens = tokenize(questionText);
  const hasMathDelimiters = /\\\(|\\\)|\\\[|\\\]|\$\$?|\\frac|\\sqrt/.test(
    questionText
  );
  const questionNumericTokens = countNumericTokens(questionText);

  const answerTexts = answerOptions.map((opt) =>
    normalizeText(typeof opt === 'object' ? opt.text : opt)
  );
  const answerTokens = answerTexts.map((t) => tokenize(t));
  const answerNumericCounts = answerTexts.map(countNumericTokens);
  const numericAnswers = answerNumericCounts.filter((n) => n > 0).length;
  const vocabContext = isVocabularyContext(question, questionText);

  if (
    questionTokens.length >= 4 &&
    !hasMathDelimiters &&
    !(questionNumericTokens > 0 && numericAnswers >= 2) &&
    answerTokens.length >= 2 &&
    !vocabContext
  ) {
    const overlaps = answerTokens.map((tokens) => {
      if (!tokens.length) return 0;
      const overlap = tokens.filter((t) => questionTokens.includes(t)).length;
      return overlap / tokens.length;
    });
    const lowOverlap = overlaps.every((ratio) => ratio < 0.1);
    const genericCount = answerTexts.filter((t) =>
      GENERIC_OPTIONS.has(t.toLowerCase())
    ).length;
    const shortCount = answerTokens.filter((t) => t.length <= 2).length;

    if (
      lowOverlap &&
      (genericCount >= 2 || shortCount >= answerTokens.length)
    ) {
      addIssue('FILLER_MISMATCH', {
        field: 'answerOptions',
        raw: answerTexts.join(' | '),
        patternKey: `filler-${genericCount}-${shortCount}`,
      });
    }
  }

  return issues;
}

const AUDIT_STORAGE_KEY = 'superAdminAuditState.v1';

function loadAuditState() {
  if (typeof window === 'undefined') return { version: 1, byQuestion: {} };
  try {
    const raw = window.localStorage.getItem(AUDIT_STORAGE_KEY);
    if (!raw) return { version: 1, byQuestion: {} };
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') {
      return { version: 1, byQuestion: {} };
    }
    return {
      version: 1,
      byQuestion: parsed.byQuestion || {},
    };
  } catch (e) {
    return { version: 1, byQuestion: {} };
  }
}

function saveAuditState(state) {
  if (typeof window === 'undefined') return;
  try {
    window.localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    // ignore persistence errors
  }
}

function defaultStatusForIssue(issue) {
  if (!issue) return 'approved';
  if (issue.severity === 'BLOCKER' || issue.severity === 'MAJOR') {
    return 'needs-fix';
  }
  return 'approved';
}

export default function SuperAdminAllQuestions() {
  const [allQuestions, setAllQuestions] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedSubject, setSelectedSubject] = useState(null);
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [jumpTo, setJumpTo] = useState('');
  const [filterType, setFilterType] = useState('all');
  const [issueFilter, setIssueFilter] = useState('all');
  const [statusFilter, setStatusFilter] = useState('all');
  const [confidenceFilter, setConfidenceFilter] = useState('all');
  const [error, setError] = useState('');
  const [auditState, setAuditState] = useState(() => loadAuditState());

  const normalizeSubjectKey = (value) =>
    String(value || '')
      .toLowerCase()
      .replace(/[_-]+/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

  const stringLooksLikeHasImage = (value) => {
    if (typeof value !== 'string') return false;
    const s = value.toLowerCase();
    // Covers legacy passages that embed images directly via HTML
    if (s.includes('<img')) return true;
    // Covers common image paths and file extensions
    if (s.includes('/images/') || s.includes('images/')) return true;
    if (/(?:^|[^a-z])images\//i.test(value)) return true;
    if (/\.(png|jpe?g|gif|svg|webp)(\?|#|$)/i.test(value)) return true;
    return false;
  };

  const questionHasImage = (q) => {
    if (!q || typeof q !== 'object') return false;
    const content = q.content && typeof q.content === 'object' ? q.content : {};

    const direct =
      q.image ||
      q.imageUrl ||
      q.imageURL ||
      q.graphic ||
      (q.stimulusImage && q.stimulusImage.src) ||
      q.stimulusImage ||
      content.image ||
      content.imageURL ||
      content.imageUrl;

    if (typeof direct === 'string') {
      if (direct.trim()) return true;
    } else if (direct) {
      return true;
    }

    // Legacy datasets sometimes mark image questions by type
    if (String(q.type || '').toLowerCase() === 'image') return true;

    // Some datasets store stimulus as object or HTML string
    if (typeof q.stimulus === 'object' && q.stimulus) {
      const stim = q.stimulus;
      if (typeof stim.image === 'string' && stim.image.trim()) return true;
      if (typeof stim.src === 'string' && stim.src.trim()) return true;
    }
    if (stringLooksLikeHasImage(q.stimulus)) return true;

    // Embedded images inside passage/question/questionText HTML
    const maybeHtml = [
      q.passage,
      q.question,
      q.questionText,
      content.passage,
      content.question,
      content.questionText,
    ];
    return maybeHtml.some(stringLooksLikeHasImage);
  };

  // Build question list from the available catalog structure (flat arrays or nested categories)
  const rebuildFromCatalog = (catalog) => {
    if (!catalog || typeof catalog !== 'object') return [];

    let list = [];

    const addQuizQuestions = (subject, categoryLabel, quiz, quizIndex) => {
      const questionsSources = [];
      if (Array.isArray(quiz?.questions)) questionsSources.push(quiz.questions);
      if (Array.isArray(quiz?.items)) questionsSources.push(quiz.items);
      if (Array.isArray(quiz?.questionBank?.questions))
        questionsSources.push(quiz.questionBank.questions);

      const merged = questionsSources.flat();
      if (!Array.isArray(merged) || merged.length === 0) return;

      merged.forEach((q, questionIndex) => {
        const qObj = typeof q === 'object' ? q : { questionText: String(q) };
        list.push({
          id: `${subject}-${categoryLabel}-${quizIndex}-${questionIndex}`,
          subject,
          category: categoryLabel || quiz.category || 'General',
          quizTitle: quiz.title || `Quiz ${quizIndex + 1}`,
          source: 'premade',
          ...qObj,
        });
      });
    };

    Object.entries(catalog).forEach(([subject, subjData]) => {
      if (Array.isArray(subjData)) {
        subjData.forEach((quiz, quizIndex) => {
          addQuizQuestions(
            subject,
            quiz.category || 'General',
            quiz,
            quizIndex
          );
        });
        return;
      }

      // Also support root-level quizzes under the subject
      if (Array.isArray(subjData?.quizzes)) {
        subjData.quizzes.forEach((quiz, quizIndex) => {
          addQuizQuestions(
            subject,
            quiz.category || 'General',
            quiz,
            quizIndex
          );
        });
      }

      const categories = subjData?.categories || {};
      Object.entries(categories).forEach(([categoryName, catData]) => {
        catData?.quizzes?.forEach((quiz, quizIndex) => {
          addQuizQuestions(subject, categoryName, quiz, quizIndex);
        });

        catData?.topics?.forEach((topic, topicIndex) => {
          if (Array.isArray(topic?.quizzes)) {
            topic.quizzes.forEach((quiz, quizIndex) => {
              addQuizQuestions(
                subject,
                topic.title || categoryName,
                quiz,
                quizIndex
              );
            });
          }

          if (Array.isArray(topic?.questions)) {
            topic.questions.forEach((q, questionIndex) => {
              list.push({
                id: `${subject}-${categoryName}-topic-${topicIndex}-${questionIndex}`,
                subject,
                category: topic.title || categoryName,
                quizTitle: topic.title || `Topic ${topicIndex + 1}`,
                source: 'premade',
                ...q,
              });
            });
          }
        });
      });
    });

    return list;
  };

  useEffect(() => {
    const catalog =
      window.PREMADE_QUIZ_CATALOG ||
      window.AppData ||
      window.ExpandedQuizData ||
      {};

    console.log(
      '[SuperAdminAllQuestions] Initial catalog keys:',
      Object.keys(catalog)
    );

    let list = rebuildFromCatalog(catalog);
    console.log(
      '[SuperAdminAllQuestions] Initial rebuilt list length:',
      list.length
    );

    // Seed state immediately so later merges (API catalog + AI) won't get overwritten.
    setAllQuestions(list);

    // Prefer backend /api/all-quizzes when available (includes richer premade metadata like imageUrl).
    (async () => {
      try {
        const apiBase = window.API_BASE_URL || '';
        const res = await fetch(`${apiBase}/api/all-quizzes`, {
          cache: 'no-store',
        });
        if (!res.ok) return;
        const data = await res.json();
        const rebuilt = rebuildFromCatalog(data);
        if (!Array.isArray(rebuilt) || rebuilt.length === 0) return;

        console.log(
          `[SuperAdminAllQuestions] Rebuilt ${rebuilt.length} questions from /api/all-quizzes`
        );

        setAllQuestions(rebuilt);
      } catch (e) {
        console.warn('[SuperAdminAllQuestions] /api/all-quizzes fetch failed');
      }
    })();

    // If nothing yet, wait for quizDataLoaded event then rebuild once
    if (list.length === 0 && typeof window !== 'undefined') {
      const onQuizDataLoaded = (evt) => {
        console.log('[SuperAdminAllQuestions] quizDataLoaded event received');
        const nextCatalog =
          window.PREMADE_QUIZ_CATALOG || window.AppData || evt?.detail || {};
        console.log(
          '[SuperAdminAllQuestions] Event catalog keys:',
          Object.keys(nextCatalog)
        );
        const rebuilt = rebuildFromCatalog(nextCatalog);
        console.log(
          '[SuperAdminAllQuestions] Rebuilt list from event:',
          rebuilt.length
        );
        setAllQuestions((prev) => {
          if (prev.length > 0) return prev;
          return rebuilt;
        });
      };
      window.addEventListener('quizDataLoaded', onQuizDataLoaded, {
        once: true,
      });

      // Fallback: Explicitly fetch quiz files if global catalog is empty or missing questions
      // This handles cases where index.html loader failed or loaded only metadata
      (async () => {
        try {
          console.log(
            '[SuperAdminAllQuestions] Attempting direct fetch of quiz files...'
          );
          const apiBase = window.API_BASE_URL || '';
          const QUIZ_FILENAMES = [
            'math.quizzes.part1.json',
            'math.quizzes.part2.json',
            'rla.quizzes.part1.json',
            'rla.quizzes.part2.json',
            'science.quizzes.part1.json',
            'science.quizzes.part2.json',
            'social-studies.quizzes.json',
            'social-studies.extras.json',
            'workforce.quizzes.json',
          ];

          const fetches = QUIZ_FILENAMES.map((f) =>
            fetch(`${apiBase}/quizzes/${f}`)
              .then((r) => (r.ok ? r.json() : null))
              .catch((e) => null)
          );

          const results = await Promise.all(fetches);
          const validResults = results.filter(
            (r) => r && typeof r === 'object'
          );

          if (validResults.length > 0) {
            console.log(
              `[SuperAdminAllQuestions] Directly fetched ${validResults.length} quiz files`
            );

            // Build a temporary catalog from these files
            const tempCatalog = {};
            validResults.forEach((data) => {
              if (!data.subject) return;
              if (!tempCatalog[data.subject]) {
                tempCatalog[data.subject] = { categories: {} };
              }

              // Merge categories
              if (data.categories) {
                Object.entries(data.categories).forEach(
                  ([catName, catData]) => {
                    if (!tempCatalog[data.subject].categories[catName]) {
                      tempCatalog[data.subject].categories[catName] = {
                        quizzes: [],
                        topics: [],
                      };
                    }
                    const targetCat =
                      tempCatalog[data.subject].categories[catName];

                    // Add topics and their quizzes
                    if (Array.isArray(catData.topics)) {
                      catData.topics.forEach((topic) => {
                        targetCat.topics.push(topic);
                        if (Array.isArray(topic.quizzes)) {
                          targetCat.quizzes.push(...topic.quizzes);
                        }
                      });
                    }

                    // Add direct quizzes
                    if (Array.isArray(catData.quizzes)) {
                      targetCat.quizzes.push(...catData.quizzes);
                    }
                  }
                );
              }
            });

            const directList = rebuildFromCatalog(tempCatalog);
            console.log(
              `[SuperAdminAllQuestions] Rebuilt ${directList.length} questions from direct fetch`
            );

            if (directList.length > 0) {
              setAllQuestions((prev) => {
                // Merge with existing, avoiding duplicates by ID
                const existingIds = new Set(prev.map((q) => q.id));
                const uniqueNew = directList.filter(
                  (q) => !existingIds.has(q.id)
                );
                return [...prev, ...uniqueNew];
              });
            }
          }
        } catch (err) {
          console.error('[SuperAdminAllQuestions] Direct fetch failed:', err);
        }
      })();
    }

    // Fetch AI-generated questions
    const apiBase = window.API_BASE_URL || '';
    const token = localStorage.getItem('appToken');

    fetch(`${apiBase}/api/admin/all-questions`, {
      headers: token
        ? {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json',
          }
        : { 'Content-Type': 'application/json' },
    })
      .then((res) => {
        if (!res.ok) {
          throw new Error(`Failed to fetch AI questions: ${res.status}`);
        }
        return res.json();
      })
      .then((aiRows) => {
        const aiQuestions = Array.isArray(aiRows)
          ? aiRows.map((row, idx) => ({
              id: `ai-${row.id || idx}`,
              subject: row.subject || 'AI Generated',
              category: row.topic || 'AI Bank',
              quizTitle: 'AI Generated',
              source: 'ai',
              ...row.question_json,
            }))
          : [];

        setAllQuestions((prev) => {
          const base = Array.isArray(prev) && prev.length > 0 ? prev : list;
          const existingIds = new Set(base.map((q) => q.id));
          const uniqueAi = aiQuestions.filter((q) => !existingIds.has(q.id));
          return [...base, ...uniqueAi];
        });
      })
      .catch((err) => {
        console.error('Failed to fetch AI questions:', err);
        setError(err.message);
        setAllQuestions((prev) => {
          if (Array.isArray(prev) && prev.length > 0) return prev;
          return list;
        });
      })
      .finally(() => {
        setLoading(false);
      });
  }, []);

  useEffect(() => {
    saveAuditState(auditState);
  }, [auditState]);

  const ensureQuestionState = (questionId) => {
    return (
      auditState.byQuestion[questionId] || {
        status: 'approved',
        notes: '',
        history: [],
        issueStates: {},
        updatedAt: null,
      }
    );
  };

  const updateQuestionState = (questionId, updater) => {
    setAuditState((prev) => {
      const current = prev.byQuestion[questionId] || {
        status: 'approved',
        notes: '',
        history: [],
        issueStates: {},
        updatedAt: null,
      };
      const nextState = updater(current);
      return {
        ...prev,
        byQuestion: {
          ...prev.byQuestion,
          [questionId]: nextState,
        },
      };
    });
  };

  const updateIssueStatus = (questionId, issueId, status, note) => {
    updateQuestionState(questionId, (current) => {
      const now = new Date().toISOString();
      const issueState = current.issueStates?.[issueId] || {
        status: 'needs-fix',
        history: [],
        updatedAt: null,
        note: '',
      };
      const nextIssueState = {
        ...issueState,
        status,
        updatedAt: now,
        note: note != null ? String(note) : issueState.note,
        history: [...(issueState.history || []), { at: now, status }],
      };
      return {
        ...current,
        updatedAt: now,
        issueStates: {
          ...(current.issueStates || {}),
          [issueId]: nextIssueState,
        },
      };
    });
  };

  const updateQuestionStatus = (questionId, status) => {
    updateQuestionState(questionId, (current) => {
      const now = new Date().toISOString();
      return {
        ...current,
        status,
        updatedAt: now,
        history: [...(current.history || []), { at: now, status }],
      };
    });
  };

  const updateQuestionNotes = (questionId, notes) => {
    updateQuestionState(questionId, (current) => ({
      ...current,
      notes,
      updatedAt: new Date().toISOString(),
    }));
  };

  const applyIssueStatusBatch = (items, status, note) => {
    setAuditState((prev) => {
      const next = {
        ...prev,
        byQuestion: { ...prev.byQuestion },
      };
      const now = new Date().toISOString();

      items.forEach(({ questionId, issueId }) => {
        const current = next.byQuestion[questionId] || {
          status: 'approved',
          notes: '',
          history: [],
          issueStates: {},
          updatedAt: null,
        };
        const issueState = current.issueStates?.[issueId] || {
          status: 'needs-fix',
          history: [],
          updatedAt: null,
          note: '',
        };
        const nextIssueState = {
          ...issueState,
          status,
          updatedAt: now,
          note: note != null ? String(note) : issueState.note,
          history: [...(issueState.history || []), { at: now, status }],
        };

        next.byQuestion[questionId] = {
          ...current,
          updatedAt: now,
          issueStates: {
            ...(current.issueStates || {}),
            [issueId]: nextIssueState,
          },
        };
      });

      return next;
    });
  };

  const BATCH_CONFIRM_THRESHOLD = 25;

  const handleBatchAction = (items, status, options = {}) => {
    if (!Array.isArray(items) || items.length === 0) return;

    if (items.length > BATCH_CONFIRM_THRESHOLD) {
      const ok = window.confirm(
        `Confirm ${status.replace('-', ' ')} for ${items.length} issues?`
      );
      if (!ok) return;
    }

    if (status === 'ignored') {
      const note = window.prompt(
        'Provide a short note to ignore these issues:'
      );
      if (!note || !note.trim()) return;
      applyIssueStatusBatch(items, status, note.trim());
      return;
    }

    if (options.disableApprove) return;

    applyIssueStatusBatch(items, status);
  };

  // Filter questions by selected subject
  const subjectQuestionsBase = useMemo(() => {
    if (!selectedSubject) return [];
    let filtered = allQuestions.filter((q) => {
      const s = normalizeSubjectKey(q.subject);
      const sel = normalizeSubjectKey(selectedSubject);
      if (sel === 'rla')
        return s.includes('rla') || s.includes('language arts');
      return s.includes(sel);
    });

    if (filterType === 'images') {
      filtered = filtered.filter(questionHasImage);
    } else if (filterType === 'missing-images') {
      filtered = filtered.filter((q) => {
        return (
          (q.content && q.content.imageURL === '') ||
          (q.content && q.content.image === '') ||
          q.image === '' ||
          q.imageUrl === ''
        );
      });
    } else if (filterType === 'no-images') {
      filtered = filtered.filter((q) => {
        return !questionHasImage(q);
      });
    } else if (filterType === 'passage') {
      filtered = filtered.filter((q) => !!q.passage);
    } else if (filterType === 'standalone') {
      filtered = filtered.filter((q) => !q.passage);
    }

    return filtered;
  }, [allQuestions, selectedSubject, filterType]);

  const auditIssuesById = useMemo(() => {
    const map = new Map();
    subjectQuestionsBase.forEach((q) => {
      const baseIssues = buildAuditIssues(q);
      const questionState = auditState.byQuestion?.[q.id];
      const regressionIssues = [];

      if (questionState && questionState.issueStates) {
        baseIssues.forEach((issue) => {
          const prior = questionState.issueStates?.[issue.id];
          if (prior?.status === 'fixed') {
            regressionIssues.push({
              id: `REGRESSION:${issue.id}`,
              code: 'REGRESSION',
              severity: ISSUE_DEFS.REGRESSION.severity,
              label: ISSUE_DEFS.REGRESSION.label,
              description: ISSUE_DEFS.REGRESSION.description,
              confidence: ISSUE_DEFS.REGRESSION.confidence,
              why: ISSUE_WHY.REGRESSION,
              field: issue.field,
              raw: issue.raw,
              patternKey: issue.patternKey,
              regressionOf: issue.id,
              fixedAt: prior.updatedAt || null,
              fixedNote: prior.note || null,
            });
          }
        });
      }

      map.set(q.id, [...baseIssues, ...regressionIssues]);
    });
    return map;
  }, [subjectQuestionsBase, auditState]);

  const issueCodeOptions = useMemo(() => {
    const codes = new Set();
    auditIssuesById.forEach((issues) => {
      issues.forEach((issue) => codes.add(issue.code));
    });
    return Array.from(codes).sort();
  }, [auditIssuesById]);

  const getIssueStatus = (questionId, issue) => {
    const questionState = auditState.byQuestion?.[questionId];
    if (!questionState || !issue) return defaultStatusForIssue(issue);
    const issueState = questionState.issueStates?.[issue.id];
    return issueState?.status || defaultStatusForIssue(issue);
  };

  const getQuestionStatus = (questionId, issues) => {
    const questionState = auditState.byQuestion?.[questionId];
    if (questionState && Array.isArray(questionState.history)) {
      if (questionState.history.length > 0) {
        return questionState.status || 'approved';
      }
    }
    if (!issues || issues.length === 0) return 'approved';
    const statuses = issues.map((issue) => getIssueStatus(questionId, issue));
    if (statuses.includes('needs-fix')) return 'needs-fix';
    if (statuses.includes('fixed')) return 'fixed';
    if (statuses.includes('ignored')) return 'ignored';
    return 'approved';
  };

  const auditTelemetry = useMemo(() => {
    const total = subjectQuestionsBase.length;
    let flagged = 0;
    let reviewed = 0;
    let remainingBlockers = 0;

    subjectQuestionsBase.forEach((q) => {
      const issues = auditIssuesById.get(q.id) || [];
      if (issues.length > 0) flagged += 1;

      const state = auditState.byQuestion?.[q.id];
      const hasReview =
        (state?.history && state.history.length > 0) ||
        (state?.issueStates && Object.keys(state.issueStates).length > 0) ||
        (state?.notes && state.notes.trim().length > 0);
      if (hasReview) reviewed += 1;

      const hasOpenBlocker = issues.some((issue) => {
        if (issue.severity !== 'BLOCKER') return false;
        const status = getIssueStatus(q.id, issue);
        return status === 'needs-fix';
      });
      if (hasOpenBlocker) remainingBlockers += 1;
    });

    return {
      total,
      flagged,
      reviewed,
      remainingBlockers,
      reviewedPercent: total > 0 ? Math.round((reviewed / total) * 100) : 0,
    };
  }, [subjectQuestionsBase, auditIssuesById, auditState]);

  const subjectQuestions = useMemo(() => {
    return subjectQuestionsBase.filter((q) => {
      const issues = auditIssuesById.get(q.id) || [];
      if (issueFilter === 'flagged' && issues.length === 0) return false;
      if (issueFilter === 'blocker') {
        if (!issues.some((i) => i.severity === 'BLOCKER')) return false;
      }
      if (issueFilter === 'major') {
        if (!issues.some((i) => i.severity === 'MAJOR')) return false;
      }
      if (
        issueFilter !== 'all' &&
        issueFilter !== 'flagged' &&
        issueFilter !== 'blocker' &&
        issueFilter !== 'major'
      ) {
        if (!issues.some((i) => i.code === issueFilter)) return false;
      }

      if (statusFilter !== 'all') {
        const status = getQuestionStatus(q.id, issues);
        if (status !== statusFilter) return false;
      }

      if (confidenceFilter !== 'all') {
        if (!issues.some((i) => i.confidence === confidenceFilter)) {
          return false;
        }
      }

      return true;
    });
  }, [
    subjectQuestionsBase,
    auditIssuesById,
    issueFilter,
    statusFilter,
    confidenceFilter,
    auditState,
  ]);

  const issueGroups = useMemo(() => {
    const groups = new Map();
    subjectQuestionsBase.forEach((q) => {
      const issues = auditIssuesById.get(q.id) || [];
      issues.forEach((issue, idx) => {
        const patternKey = issue.patternKey || `${issue.code}-${idx}`;
        const key = `${issue.code}::${patternKey}`;
        if (!groups.has(key)) {
          groups.set(key, {
            key,
            code: issue.code,
            patternKey,
            severity: issue.severity,
            count: 0,
            questionIds: new Set(),
            issueIds: [],
            sampleQuiz: q.quizTitle,
            sampleCategory: q.category,
          });
        }
        const group = groups.get(key);
        group.count += 1;
        group.questionIds.add(q.id);
        group.issueIds.push({ questionId: q.id, issueId: issue.id });
      });
    });
    return Array.from(groups.values())
      .filter((g) => g.count > 1)
      .sort((a, b) => b.count - a.count);
  }, [subjectQuestionsBase, auditIssuesById]);

  // Reset index when filter changes
  useEffect(() => {
    setSelectedIndex(0);
  }, [filterType, issueFilter, statusFilter, confidenceFilter]);

  const currentQuestion = subjectQuestions[selectedIndex];

  const goToQuestionNumber = (raw) => {
    const total = subjectQuestions.length;
    if (!total) return;
    const n = Number(raw);
    if (!Number.isFinite(n)) return;
    const clamped = Math.min(total, Math.max(1, Math.floor(n)));
    setSelectedIndex(clamped - 1);
  };

  if (loading) {
    return (
      <div className="p-6">
        <h1 className="text-3xl font-bold mb-4 dark:text-white">
          Question Audit System
        </h1>
        <p className="text-gray-500 dark:text-gray-400">Loading questions...</p>
      </div>
    );
  }

  if (!selectedSubject) {
    return (
      <div className="p-6">
        <h1 className="text-3xl font-bold mb-8 dark:text-white">
          Question Audit System
        </h1>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-4xl">
          {['Math', 'RLA', 'Social Studies', 'Science'].map((subj) => (
            <button
              key={subj}
              onClick={() => {
                setSelectedSubject(subj);
                setSelectedIndex(0);
              }}
              className="p-10 text-2xl font-bold bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl hover:bg-blue-50 dark:hover:bg-slate-700 shadow-sm hover:shadow-md transition-all text-slate-800 dark:text-white"
            >
              {subj}
            </button>
          ))}
        </div>
        <div className="mt-8 text-slate-500">
          Total Questions Loaded: {allQuestions.length}
        </div>
      </div>
    );
  }

  return (
    <div className="p-6 max-w-6xl mx-auto">
      <button
        onClick={() => setSelectedSubject(null)}
        className="mb-6 text-blue-600 dark:text-blue-400 hover:underline flex items-center gap-2 font-medium"
      >
        &larr; Back to Subject Selection
      </button>

      <div className="flex flex-col md:flex-row md:items-center justify-between mb-8 gap-4">
        <h1 className="text-3xl font-bold dark:text-white">
          {selectedSubject} Audit
        </h1>

        <div className="flex flex-wrap items-center gap-3">
          <div className="flex items-center gap-2 bg-white dark:bg-slate-800 p-2 rounded-lg border border-slate-200 dark:border-slate-700 shadow-sm">
            <label className="font-medium text-slate-700 dark:text-slate-300 pl-2 text-sm">
              Filter:
            </label>
            <select
              value={filterType}
              onChange={(e) => setFilterType(e.target.value)}
              className="border-none bg-transparent py-1 pl-2 pr-8 font-medium text-sm focus:ring-0 cursor-pointer dark:text-white"
            >
              <option value="all" className="dark:bg-slate-800">
                All Questions
              </option>
              <option value="images" className="dark:bg-slate-800">
                With Images
              </option>
              <option value="missing-images" className="dark:bg-slate-800">
                Missing Images (Empty Field)
              </option>
              <option value="no-images" className="dark:bg-slate-800">
                Text Only
              </option>
              <option value="passage" className="dark:bg-slate-800">
                Passage Based
              </option>
              <option value="standalone" className="dark:bg-slate-800">
                Standalone
              </option>
            </select>
          </div>

          <div className="flex items-center gap-2 bg-white dark:bg-slate-800 p-2 rounded-lg border border-slate-200 dark:border-slate-700 shadow-sm">
            <label className="font-medium text-slate-700 dark:text-slate-300 pl-2 text-sm">
              Issues:
            </label>
            <select
              value={issueFilter}
              onChange={(e) => setIssueFilter(e.target.value)}
              className="border-none bg-transparent py-1 pl-2 pr-8 font-medium text-sm focus:ring-0 cursor-pointer dark:text-white"
            >
              <option value="all" className="dark:bg-slate-800">
                All
              </option>
              <option value="flagged" className="dark:bg-slate-800">
                Flagged Only
              </option>
              <option value="blocker" className="dark:bg-slate-800">
                Blockers
              </option>
              <option value="major" className="dark:bg-slate-800">
                Major
              </option>
              {issueCodeOptions.map((code) => (
                <option key={code} value={code} className="dark:bg-slate-800">
                  {code}
                </option>
              ))}
            </select>
          </div>

          <div className="flex items-center gap-2 bg-white dark:bg-slate-800 p-2 rounded-lg border border-slate-200 dark:border-slate-700 shadow-sm">
            <label className="font-medium text-slate-700 dark:text-slate-300 pl-2 text-sm">
              Status:
            </label>
            <select
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
              className="border-none bg-transparent py-1 pl-2 pr-8 font-medium text-sm focus:ring-0 cursor-pointer dark:text-white"
            >
              <option value="all" className="dark:bg-slate-800">
                All
              </option>
              <option value="needs-fix" className="dark:bg-slate-800">
                Needs Fix
              </option>
              <option value="fixed" className="dark:bg-slate-800">
                Fixed
              </option>
              <option value="ignored" className="dark:bg-slate-800">
                Ignored
              </option>
              <option value="approved" className="dark:bg-slate-800">
                Approved
              </option>
            </select>
          </div>

          <div className="flex items-center gap-2 bg-white dark:bg-slate-800 p-2 rounded-lg border border-slate-200 dark:border-slate-700 shadow-sm">
            <label className="font-medium text-slate-700 dark:text-slate-300 pl-2 text-sm">
              Confidence:
            </label>
            <select
              value={confidenceFilter}
              onChange={(e) => setConfidenceFilter(e.target.value)}
              className="border-none bg-transparent py-1 pl-2 pr-8 font-medium text-sm focus:ring-0 cursor-pointer dark:text-white"
            >
              <option value="all" className="dark:bg-slate-800">
                All
              </option>
              <option value="high" className="dark:bg-slate-800">
                High
              </option>
              <option value="medium" className="dark:bg-slate-800">
                Medium
              </option>
              <option value="low" className="dark:bg-slate-800">
                Low
              </option>
            </select>
          </div>

          <div className="flex items-center gap-3 bg-white dark:bg-slate-800 p-2 rounded-lg border border-slate-200 dark:border-slate-700 shadow-sm">
            <button
              onClick={() => setSelectedIndex(Math.max(0, selectedIndex - 1))}
              disabled={selectedIndex === 0}
              className="p-2 rounded hover:bg-slate-100 dark:hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed text-slate-600 dark:text-slate-400"
              title="Previous Question"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-5 w-5"
                viewBox="0 0 20 20"
                fill="currentColor"
              >
                <path
                  fillRule="evenodd"
                  d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                  clipRule="evenodd"
                />
              </svg>
            </button>

            <div className="flex items-center">
              <label className="font-medium text-slate-700 dark:text-slate-300 pl-2 hidden sm:inline">
                Question:
              </label>
              <select
                value={selectedIndex}
                onChange={(e) => setSelectedIndex(Number(e.target.value))}
                className="border-none bg-transparent py-1 pl-2 pr-8 font-bold text-lg focus:ring-0 cursor-pointer dark:text-white"
              >
                {subjectQuestions.map((_, idx) => (
                  <option key={idx} value={idx} className="dark:bg-slate-800">
                    {idx + 1} of {subjectQuestions.length}
                  </option>
                ))}
              </select>
            </div>

            <div className="hidden md:flex items-center gap-2 pl-2 border-l border-slate-200 dark:border-slate-700">
              <label className="font-medium text-slate-700 dark:text-slate-300 text-sm">
                Go to:
              </label>
              <input
                type="number"
                min={1}
                max={subjectQuestions.length}
                value={jumpTo}
                onChange={(e) => setJumpTo(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') goToQuestionNumber(jumpTo);
                }}
                className="w-24 px-2 py-1 text-sm rounded border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900 text-slate-800 dark:text-slate-100"
                placeholder="#"
              />
              <button
                onClick={() => goToQuestionNumber(jumpTo)}
                className="px-3 py-1 text-sm font-medium rounded bg-blue-600 text-white hover:bg-blue-700 transition-colors"
              >
                Go
              </button>
            </div>

            <button
              onClick={() =>
                setSelectedIndex(
                  Math.min(subjectQuestions.length - 1, selectedIndex + 1)
                )
              }
              disabled={selectedIndex === subjectQuestions.length - 1}
              className="p-2 rounded hover:bg-slate-100 dark:hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed text-slate-600 dark:text-slate-400"
              title="Next Question"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-5 w-5"
                viewBox="0 0 20 20"
                fill="currentColor"
              >
                <path
                  fillRule="evenodd"
                  d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                  clipRule="evenodd"
                />
              </svg>
            </button>
          </div>
        </div>
      </div>

      <div className="mb-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
        <div className="rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4">
          <div className="text-xs uppercase tracking-wide text-slate-500">
            Total Questions
          </div>
          <div className="text-2xl font-bold text-slate-900 dark:text-white">
            {auditTelemetry.total}
          </div>
        </div>
        <div className="rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4">
          <div className="text-xs uppercase tracking-wide text-slate-500">
            Flagged Questions
          </div>
          <div className="text-2xl font-bold text-amber-600 dark:text-amber-400">
            {auditTelemetry.flagged}
          </div>
        </div>
        <div className="rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4">
          <div className="text-xs uppercase tracking-wide text-slate-500">
            Reviewed
          </div>
          <div className="text-2xl font-bold text-emerald-600 dark:text-emerald-400">
            {auditTelemetry.reviewed} ({auditTelemetry.reviewedPercent}%)
          </div>
        </div>
        <div className="rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 p-4">
          <div className="text-xs uppercase tracking-wide text-slate-500">
            Remaining Blockers
          </div>
          <div className="text-2xl font-bold text-red-600 dark:text-red-400">
            {auditTelemetry.remainingBlockers}
          </div>
        </div>
      </div>

      {issueGroups.length > 0 && (
        <div className="mb-8 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl p-5 shadow-sm">
          <div className="flex items-center justify-between mb-4">
            <div>
              <h2 className="text-lg font-bold text-slate-800 dark:text-white">
                Repeated Issue Groups
              </h2>
              <p className="text-sm text-slate-500 dark:text-slate-400">
                Grouped by issue code and structural pattern for batch review.
              </p>
            </div>
            <span className="text-xs font-semibold text-slate-500">
              Groups: {issueGroups.length}
            </span>
          </div>

          <div className="space-y-3 max-h-[280px] overflow-y-auto pr-2">
            {issueGroups.slice(0, 20).map((group) => (
              <div
                key={group.key}
                className="flex flex-col md:flex-row md:items-center md:justify-between gap-3 p-3 rounded-lg border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-900/30"
              >
                <div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs font-bold uppercase tracking-wide text-slate-500">
                      {group.code}
                    </span>
                    <span
                      className={`text-xs font-semibold px-2 py-0.5 rounded-full ${
                        group.severity === 'BLOCKER'
                          ? 'bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-200'
                          : 'bg-amber-100 text-amber-700 dark:bg-amber-900/40 dark:text-amber-200'
                      }`}
                    >
                      {group.severity}
                    </span>
                    <span className="text-xs text-slate-500">
                      x{group.count}
                    </span>
                  </div>
                  <div className="text-xs text-slate-500 mt-1">
                    {group.sampleCategory}  {group.sampleQuiz}
                  </div>
                  <div className="text-xs text-slate-400 mt-1">
                    Pattern: {group.patternKey}
                  </div>
                </div>

                <div className="flex flex-wrap gap-2">
                  <button
                    type="button"
                    onClick={() =>
                      handleBatchAction(group.issueIds, 'needs-fix')
                    }
                    className="px-3 py-1 text-xs font-semibold rounded bg-red-600 text-white hover:bg-red-700"
                  >
                    Mark Needs Fix
                  </button>
                  <button
                    type="button"
                    onClick={() => handleBatchAction(group.issueIds, 'fixed')}
                    className="px-3 py-1 text-xs font-semibold rounded bg-emerald-600 text-white hover:bg-emerald-700"
                  >
                    Mark Fixed
                  </button>
                  <button
                    type="button"
                    onClick={() => handleBatchAction(group.issueIds, 'ignored')}
                    className="px-3 py-1 text-xs font-semibold rounded bg-slate-500 text-white hover:bg-slate-600"
                  >
                    Ignore
                  </button>
                  <button
                    type="button"
                    onClick={() =>
                      handleBatchAction(group.issueIds, 'approved', {
                        disableApprove: group.severity === 'BLOCKER',
                      })
                    }
                    disabled={group.severity === 'BLOCKER'}
                    className={`px-3 py-1 text-xs font-semibold rounded text-white ${
                      group.severity === 'BLOCKER'
                        ? 'bg-blue-300 cursor-not-allowed'
                        : 'bg-blue-600 hover:bg-blue-700'
                    }`}
                  >
                    Approve
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {currentQuestion ? (
        <AuditQuestionDisplay
          question={currentQuestion}
          index={selectedIndex + 1}
          issues={auditIssuesById.get(currentQuestion.id) || []}
          issueStatusFor={(issue) => getIssueStatus(currentQuestion.id, issue)}
          questionStatus={getQuestionStatus(
            currentQuestion.id,
            auditIssuesById.get(currentQuestion.id) || []
          )}
          onUpdateIssueStatus={(issueId, status) =>
            updateIssueStatus(currentQuestion.id, issueId, status)
          }
          onUpdateQuestionStatus={(status) =>
            updateQuestionStatus(currentQuestion.id, status)
          }
          onUpdateNotes={(notes) =>
            updateQuestionNotes(currentQuestion.id, notes)
          }
          auditNotes={ensureQuestionState(currentQuestion.id).notes || ''}
          auditHistory={ensureQuestionState(currentQuestion.id).history || []}
        />
      ) : (
        <div className="p-12 text-center bg-slate-50 dark:bg-slate-800/50 rounded-xl border border-dashed border-slate-300 dark:border-slate-700">
          <p className="text-xl text-slate-500 mb-4">
            No questions found for {selectedSubject}.
          </p>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors mr-2"
          >
            Reload Page
          </button>
          <button
            onClick={async () => {
              console.log('Attempting debug fetch...');
              try {
                const urls = [
                  '/quizzes/math.quizzes.part1.json',
                  'http://localhost:3002/quizzes/math.quizzes.part1.json',
                  'http://localhost:3003/quizzes/math.quizzes.part1.json',
                ];
                for (const url of urls) {
                  try {
                    ('social-studies.quizzes.part1.json',
                      'social-studies.quizzes.part2.json',
                      'social-studies.quizzes.json',
                      console.log(
                        `Fetch ${url}: ${res.status} ${res.statusText}`
                      ));
                    if (res.ok) {
                      const data = await res.json();
                      console.log('Data sample:', data);
                      alert(`Success fetching ${url}`);
                    }
                  } catch (e) {
                    console.error(`Failed to fetch ${url}:`, e);
                  }
                }
              } catch (e) {
                console.error('Debug error:', e);
              }
            }}
            className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
          >
            Debug Fetch
          </button>
          <div className="mt-4 text-xs text-slate-400 text-left max-w-md mx-auto overflow-auto max-h-40">
            <p>Debug Info:</p>
            <p>Total Questions: {allQuestions.length}</p>
            <p>
              Catalog Keys:{' '}
              {Object.keys(window.PREMADE_QUIZ_CATALOG || {}).join(', ')}
            </p>
            <p>AppData Keys: {Object.keys(window.AppData || {}).join(', ')}</p>
          </div>
        </div>
      )}
    </div>
  );
}

function AuditQuestionDisplay({
  question,
  index,
  issues,
  issueStatusFor,
  questionStatus,
  onUpdateIssueStatus,
  onUpdateQuestionStatus,
  onUpdateNotes,
  auditNotes,
  auditHistory,
}) {
  // Handle nested content object (found in some Social Studies quizzes)
  const content = question.content || {};

  const rawQuestionText =
    question.question ||
    question.questionText ||
    content.questionText ||
    content.question ||
    'No question text';

  const rawPassage = question.passage || content.passage || '';

  // Render text with KaTeX for proper math formula display
  const questionText = renderTextWithKatex(rawQuestionText);

  // If passage contains HTML tags, don't escape it - render as-is
  // Only process with KaTeX if it contains math delimiters but no HTML tags
  const passageHasHtml = /<[a-z][\s\S]*>/i.test(rawPassage);
  const passage = passageHasHtml ? rawPassage : renderTextWithKatex(rawPassage);

  const image =
    question.image ||
    question.imageUrl ||
    question.imageURL ||
    question.graphic ||
    question.stimulusImage?.src ||
    question.stimulusImage ||
    content.imageURL ||
    content.image ||
    (typeof question.stimulus === 'object'
      ? question.stimulus.image || question.stimulus.src
      : null) ||
    null;

  const answerOptions = question.answerOptions || [];
  const correctAnswer = question.correctAnswer;
  const rawRationale = question.rationale || question.explanation || '';
  const rationaleHasHtml = /<[a-z][\s\S]*>/i.test(rawRationale);
  const rationale = rationaleHasHtml
    ? rawRationale
    : renderTextWithKatex(rawRationale);

  const resolvedIssues = Array.isArray(issues)
    ? [...issues].sort((a, b) => {
        const order = { BLOCKER: 0, MAJOR: 1, MINOR: 2 };
        return (order[a.severity] ?? 3) - (order[b.severity] ?? 3);
      })
    : [];
  const issueCount = resolvedIssues.length;

  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
      {/* Left Column: Question Preview (Quiz Format) */}
      <div className="lg:col-span-2 space-y-6">
        <div className="bg-white dark:bg-slate-800 p-8 rounded-xl shadow-sm border border-slate-200 dark:border-slate-700">
          <div className="mb-6">
            <span className="inline-block bg-blue-100 text-blue-800 text-xs font-bold px-3 py-1 rounded-full uppercase tracking-wide dark:bg-blue-900/30 dark:text-blue-300">
              Question Preview
            </span>
          </div>

          {passage && (
            <div className="mb-8 p-6 bg-slate-50 dark:bg-slate-900/50 rounded-lg border-l-4 border-slate-300 dark:border-slate-600 italic text-slate-700 dark:text-slate-300 leading-relaxed">
              <div dangerouslySetInnerHTML={{ __html: passage }} />
            </div>
          )}

          {image && (
            <div className="mb-8 flex justify-center bg-slate-50 dark:bg-black/20 p-4 rounded-lg">
              <img
                src={normalizeImageUrl(image)}
                alt="Question"
                className="max-w-full max-h-[400px] h-auto rounded shadow-sm"
              />
            </div>
          )}

          <div className="text-xl mb-8 font-medium text-slate-900 dark:text-white leading-relaxed">
            <div dangerouslySetInnerHTML={{ __html: questionText }} />
          </div>

          <div className="space-y-4">
            {answerOptions.map((opt, i) => {
              const rawOptText = typeof opt === 'object' ? opt.text : opt;
              const optText = renderTextWithKatex(rawOptText);
              const isCorrect =
                (typeof opt === 'object' && opt.isCorrect) ||
                correctAnswer === rawOptText ||
                correctAnswer === String.fromCharCode(65 + i); // Fallback check

              return (
                <div
                  key={i}
                  className={`p-4 rounded-lg border-2 transition-colors ${
                    isCorrect
                      ? 'bg-green-50 border-green-500 dark:bg-green-900/10 dark:border-green-500/50'
                      : 'border-slate-200 dark:border-slate-700 hover:border-slate-300 dark:hover:border-slate-600'
                  }`}
                >
                  <div className="flex items-start gap-4">
                    <div
                      className={`w-8 h-8 flex-shrink-0 flex items-center justify-center rounded-full font-bold text-sm border-2 ${
                        isCorrect
                          ? 'bg-green-500 text-white border-green-500'
                          : 'bg-slate-100 text-slate-500 border-slate-300 dark:bg-slate-700 dark:text-slate-300 dark:border-slate-600'
                      }`}
                    >
                      {String.fromCharCode(65 + i)}
                    </div>
                    <div className="pt-1 text-lg text-slate-800 dark:text-slate-200">
                      <div dangerouslySetInnerHTML={{ __html: optText }} />
                    </div>
                    {isCorrect && (
                      <span className="ml-auto text-xs font-bold text-green-700 dark:text-green-400 px-2 py-1 bg-green-100 dark:bg-green-900/30 rounded uppercase tracking-wider">
                        Correct Answer
                      </span>
                    )}
                  </div>
                </div>
              );
            })}
          </div>

          <div className="mt-8 pt-8 border-t border-slate-200 dark:border-slate-700">
            <div className="flex items-center justify-between mb-4">
              <h4 className="font-bold text-sm text-slate-500 uppercase tracking-wider">
                Audit Findings
              </h4>
              <span className="text-xs font-semibold text-slate-500">
                Issues: {issueCount}
              </span>
            </div>

            {issueCount === 0 ? (
              <div className="text-sm text-emerald-700 dark:text-emerald-300 bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-100 dark:border-emerald-900/40 rounded-lg p-3">
                No audit issues detected for this question.
              </div>
            ) : (
              <div className="space-y-4">
                {resolvedIssues.map((issue) => {
                  const status = issueStatusFor
                    ? issueStatusFor(issue)
                    : defaultStatusForIssue(issue);
                  const previewText = issue.math
                    ? `\\(${issue.math}\\)`
                    : issue.raw || '';
                  const renderedPreview = renderTextWithKatex(previewText);

                  return (
                    <div
                      key={issue.id}
                      className="rounded-lg border border-slate-200 dark:border-slate-700 bg-slate-50 dark:bg-slate-900/30 p-4"
                    >
                      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-3">
                        <div>
                          <div className="flex items-center gap-2">
                            <span className="text-xs font-bold uppercase tracking-wide text-slate-500">
                              {issue.label || issue.code}
                            </span>
                            <span
                              className={`text-xs font-semibold px-2 py-0.5 rounded-full ${
                                issue.severity === 'BLOCKER'
                                  ? 'bg-red-100 text-red-700 dark:bg-red-900/40 dark:text-red-200'
                                  : 'bg-amber-100 text-amber-700 dark:bg-amber-900/40 dark:text-amber-200'
                              }`}
                            >
                              {issue.severity}
                            </span>
                            <span
                              className={`text-xs font-semibold px-2 py-0.5 rounded-full ${
                                issue.confidence === 'high'
                                  ? 'bg-emerald-100 text-emerald-700 dark:bg-emerald-900/40 dark:text-emerald-200'
                                  : issue.confidence === 'medium'
                                    ? 'bg-blue-100 text-blue-700 dark:bg-blue-900/40 dark:text-blue-200'
                                    : 'bg-slate-200 text-slate-600 dark:bg-slate-700 dark:text-slate-200'
                              }`}
                              title="Audit confidence"
                            >
                              {issue.confidence?.toUpperCase() || 'MEDIUM'}
                            </span>
                          </div>
                          <div className="text-xs text-slate-500 mt-1">
                            {issue.description}
                          </div>
                          {issue.why && (
                            <div className="text-xs text-slate-500 mt-1">
                              Why flagged: {issue.why}
                            </div>
                          )}
                          {issue.fixedAt && (
                            <div className="text-xs text-slate-400 mt-1">
                              Previously fixed:{' '}
                              {new Date(issue.fixedAt).toLocaleString()}
                              {issue.fixedNote
                                ? `  Note: ${issue.fixedNote}`
                                : ''}
                            </div>
                          )}
                          {issue.field && (
                            <div className="text-xs text-slate-400 mt-1">
                              Field: {issue.field}
                            </div>
                          )}
                        </div>

                        <div className="flex items-center gap-2">
                          <label className="text-xs font-semibold text-slate-500">
                            Status
                          </label>
                          <select
                            value={status}
                            onChange={(e) =>
                              onUpdateIssueStatus(issue.id, e.target.value)
                            }
                            className="text-xs font-semibold rounded border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 px-2 py-1"
                          >
                            <option value="needs-fix">Needs Fix</option>
                            <option value="fixed">Fixed</option>
                            <option value="ignored">Ignored</option>
                            <option value="approved">Approved</option>
                          </select>
                        </div>
                      </div>

                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                          <div className="text-xs font-semibold text-slate-500 mb-2">
                            Rendered Preview
                          </div>
                          <div className="bg-white dark:bg-slate-800 rounded border border-slate-200 dark:border-slate-700 p-3 text-sm">
                            <div
                              dangerouslySetInnerHTML={{
                                __html: renderedPreview,
                              }}
                            />
                          </div>
                        </div>
                        <div>
                          <div className="text-xs font-semibold text-slate-500 mb-2">
                            Raw Source
                          </div>
                          <pre className="bg-slate-900 text-slate-100 rounded border border-slate-800 p-3 text-xs whitespace-pre-wrap max-h-40 overflow-auto">
                            {issue.raw || issue.math || ''}
                          </pre>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          {rationale && (
            <div className="mt-8 pt-8 border-t border-slate-200 dark:border-slate-700">
              <h4 className="font-bold text-sm text-slate-500 uppercase tracking-wider mb-3">
                Explanation / Rationale
              </h4>
              <div className="text-slate-700 dark:text-slate-300 leading-relaxed bg-blue-50 dark:bg-blue-900/10 p-4 rounded-lg border border-blue-100 dark:border-blue-900/20">
                <div dangerouslySetInnerHTML={{ __html: rationale }} />
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Right Column: Source Metadata */}
      <div className="lg:col-span-1">
        <div className="bg-slate-100 dark:bg-slate-900 p-6 rounded-xl border border-slate-200 dark:border-slate-700 sticky top-6">
          <h3 className="text-sm font-bold text-slate-500 uppercase tracking-wider mb-4 border-b border-slate-200 dark:border-slate-700 pb-2">
            Source Location
          </h3>
          <div className="space-y-4 text-sm">
            <div>
              <div className="text-xs text-slate-500 mb-1">Subject</div>
              <div className="font-semibold text-slate-900 dark:text-white text-lg">
                {question.subject}
              </div>
            </div>
            <div>
              <div className="text-xs text-slate-500 mb-1">Category</div>
              <div className="font-medium text-slate-800 dark:text-slate-200">
                {question.category}
              </div>
            </div>
            <div>
              <div className="text-xs text-slate-500 mb-1">
                Quiz / Topic Title
              </div>
              <div className="font-medium text-slate-800 dark:text-slate-200">
                {question.quizTitle}
              </div>
            </div>
            <div className="pt-2 border-t border-slate-200 dark:border-slate-700">
              <div className="text-xs text-slate-500 mb-1">System ID</div>
              <div className="font-mono text-xs bg-slate-200 dark:bg-slate-800 p-1 rounded break-all">
                {question.id}
              </div>
            </div>
            <div>
              <div className="text-xs text-slate-500 mb-1">Source Type</div>
              <div className="inline-block px-2 py-1 rounded text-xs font-medium bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 capitalize">
                {question.source}
              </div>
            </div>
          </div>
        </div>

        <div className="mt-6 bg-white dark:bg-slate-800 p-6 rounded-xl border border-slate-200 dark:border-slate-700 shadow-sm">
          <h3 className="text-sm font-bold text-slate-500 uppercase tracking-wider mb-4 border-b border-slate-200 dark:border-slate-700 pb-2">
            Audit Status
          </h3>
          <div className="space-y-4">
            <div>
              <div className="text-xs text-slate-500 mb-1">Question Status</div>
              <select
                value={questionStatus}
                onChange={(e) => onUpdateQuestionStatus(e.target.value)}
                className="w-full rounded border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2 text-sm font-semibold text-slate-700 dark:text-slate-200"
              >
                <option value="needs-fix">Needs Fix</option>
                <option value="fixed">Fixed</option>
                <option value="ignored">Ignored</option>
                <option value="approved">Approved</option>
              </select>
            </div>
            <div>
              <div className="text-xs text-slate-500 mb-1">Reviewer Notes</div>
              <textarea
                value={auditNotes}
                onChange={(e) => onUpdateNotes(e.target.value)}
                rows={4}
                className="w-full rounded border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2 text-sm text-slate-700 dark:text-slate-200"
                placeholder="Add reviewer notes for this question..."
              />
            </div>
            {Array.isArray(auditHistory) && auditHistory.length > 0 && (
              <div>
                <div className="text-xs text-slate-500 mb-2">History</div>
                <div className="space-y-1 max-h-32 overflow-auto text-xs text-slate-500">
                  {auditHistory
                    .slice(-6)
                    .reverse()
                    .map((h, idx) => (
                      <div
                        key={`${h.at}-${idx}`}
                        className="flex justify-between"
                      >
                        <span>{h.status}</span>
                        <span>{new Date(h.at).toLocaleString()}</span>
                      </div>
                    ))}
                </div>
              </div>
            )}
          </div>
        </div>

        <div className="mt-6 bg-white dark:bg-slate-800 p-6 rounded-xl border border-slate-200 dark:border-slate-700 shadow-sm">
          <h3 className="text-sm font-bold text-slate-500 uppercase tracking-wider mb-4 border-b border-slate-200 dark:border-slate-700 pb-2">
            Raw Source
          </h3>
          <pre className="text-xs whitespace-pre-wrap bg-slate-900 text-slate-100 rounded-lg p-3 max-h-80 overflow-auto">
            {JSON.stringify(question, null, 2)}
          </pre>
        </div>
      </div>
    </div>
  );
}
