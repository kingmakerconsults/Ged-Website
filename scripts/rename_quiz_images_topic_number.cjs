'use strict';

// Renames quiz-referenced images into a uniform scheme based on TOPIC + sequence number,
// and rewrites all repo references so questions keep working.
//
// Source of truth for "what images are used by which topic": image-audit-all-refs-v2.json
// (generated by audit-images-v2.cjs, which walks ALL_QUIZZES).
//
// Output mapping: reports/quiz_image_topic_rename_map.json

const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');
const AUDIT_ALL_REFS = path.join(ROOT, 'image-audit-all-refs-v2.json');
const PUBLIC_IMAGES_ROOT = path.join(ROOT, 'frontend', 'public', 'images');
const OUT_DIR = path.join(ROOT, 'reports');
const OUT_MAP = path.join(OUT_DIR, 'quiz_image_topic_rename_map.json');

const SUBJECT_FOLDER = {
  science: 'Science',
  math: 'Math',
  'social studies': 'Social Studies',
  'reasoning through language arts (rla)': 'RLA',
  rla: 'RLA',
};

const SKIP_DIRS = new Set([
  'node_modules',
  '.git',
  'dist',
  'build',
  '.next',
  '.cache',
  'reports',
]);

const INCLUDE_EXT = new Set([
  '.js',
  '.cjs',
  '.mjs',
  '.jsx',
  '.ts',
  '.tsx',
  '.json',
  '.md',
  '.txt',
]);

function die(msg) {
  console.error(msg);
  process.exit(1);
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function readJson(p) {
  return JSON.parse(fs.readFileSync(p, 'utf8'));
}

function normalizeUrl(u) {
  let url = String(u || '').trim();
  if (!url) return '';
  // protocol-relative local form
  if (/^\/\/images\//i.test(url)) url = '/' + url.replace(/^\/+/g, '');
  return url;
}

function urlToRelativePath(imgUrl) {
  let rel = normalizeUrl(imgUrl);
  if (!rel) return null;

  const lower = rel.toLowerCase();
  if (lower.startsWith('http://') || lower.startsWith('https://')) return null;

  rel = rel.split('?')[0];
  // strip all leading slashes
  rel = rel.replace(/^\/+/, '');
  rel = decodeURIComponent(rel);
  return rel;
}

function parseContext(context) {
  // context format: "Subject - Category - Topic - Q..." or similar
  const parts = String(context || '')
    .split(' - ')
    .map((p) => p.trim());
  const subjectRaw = parts[0] || '';
  const topicRaw = parts[2] || '';
  const subjectFolder = SUBJECT_FOLDER[subjectRaw.toLowerCase()] || 'Misc';
  return { subjectRaw, subjectFolder, topicRaw };
}

function slugifyTopic(topic) {
  const raw = String(topic || '').trim();
  if (!raw) return 'topic';

  // Keep it filesystem-friendly and sortable; preserve words but normalize separators.
  let s = raw.toLowerCase();
  s = s.replace(/\([^)]*\)/g, ''); // drop parenthetical years etc
  s = s.replace(/&/g, ' and ');
  s = s.replace(/[^a-z0-9]+/g, '_');
  s = s.replace(/^_+|_+$/g, '');
  s = s.replace(/_+/g, '_');

  if (!s) s = 'topic';

  // Limit length to keep filenames readable.
  if (s.length > 48) s = s.slice(0, 48).replace(/_+$/g, '');
  return s || 'topic';
}

function walkFiles(dir, out = []) {
  if (!fs.existsSync(dir)) return out;
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      if (SKIP_DIRS.has(e.name)) continue;
      walkFiles(full, out);
    } else {
      const ext = path.extname(e.name).toLowerCase();
      if (INCLUDE_EXT.has(ext)) out.push(full);
    }
  }
  return out;
}

function buildFileUsage(auditAll) {
  // Group by absolute file path on disk.
  // For each file, count how many times it appears per topic (within a subject).
  const byAbs = new Map();

  for (const item of auditAll) {
    if (!item || !item.exists) continue;

    const url = normalizeUrl(item.url);
    const rel = urlToRelativePath(url);
    if (!rel) continue;
    if (!rel.toLowerCase().startsWith('images/')) continue;

    const abs = item.path;
    if (!abs) continue;

    const { subjectFolder, topicRaw } = parseContext(item.context);
    const topicSlug = slugifyTopic(topicRaw);

    if (!byAbs.has(abs)) {
      byAbs.set(abs, {
        abs,
        urls: new Set([url]),
        subjectFolder,
        topicCounts: new Map([[`${subjectFolder}::${topicSlug}`, 1]]),
        topicLabel: new Map([[`${subjectFolder}::${topicSlug}`, topicRaw]]),
      });
    } else {
      const entry = byAbs.get(abs);
      entry.urls.add(url);
      const key = `${subjectFolder}::${topicSlug}`;
      entry.topicCounts.set(key, (entry.topicCounts.get(key) || 0) + 1);
      if (!entry.topicLabel.has(key)) entry.topicLabel.set(key, topicRaw);
    }
  }

  // Pick a primary subject+topic for each file: highest usage count, tie -> lexicographic.
  const files = [];
  for (const entry of byAbs.values()) {
    const keys = Array.from(entry.topicCounts.keys());
    keys.sort((a, b) => {
      const ca = entry.topicCounts.get(a) || 0;
      const cb = entry.topicCounts.get(b) || 0;
      if (cb !== ca) return cb - ca;
      return a.localeCompare(b);
    });

    const primaryKey = keys[0] || `${entry.subjectFolder}::topic`;
    const [subjectFolder, topicSlug] = primaryKey.split('::');

    files.push({
      abs: entry.abs,
      urls: Array.from(entry.urls),
      subjectFolder,
      topicSlug,
      topicTitle: entry.topicLabel.get(primaryKey) || topicSlug,
    });
  }

  return files;
}

function planRenames(files) {
  // Group by subject + topicSlug; deterministic ordering by current filename
  const groups = new Map();
  for (const f of files) {
    const gk = `${f.subjectFolder}::${f.topicSlug}`;
    if (!groups.has(gk)) groups.set(gk, []);
    groups.get(gk).push(f);
  }

  const planned = [];
  const usedDest = new Set();

  for (const [gk, items] of groups.entries()) {
    const [subjectFolder, topicSlug] = gk.split('::');

    items.sort((a, b) => {
      const an = path.basename(a.abs);
      const bn = path.basename(b.abs);
      return an.localeCompare(bn);
    });

    let counter = 1;
    for (const item of items) {
      const ext = path.extname(item.abs) || '.png';
      const newFileName = `${topicSlug}_${String(counter).padStart(
        4,
        '0'
      )}${ext.toLowerCase()}`;
      counter++;

      const destDir = path.join(PUBLIC_IMAGES_ROOT, subjectFolder);
      const destAbs = path.join(destDir, newFileName);

      const newUrl = `/images/${encodeURIComponent(
        subjectFolder
      )}/${newFileName}`.replace(/%20/g, ' ');

      const key = destAbs.toLowerCase();
      if (usedDest.has(key)) die(`Destination collision planned: ${destAbs}`);
      usedDest.add(key);

      planned.push({
        subjectFolder,
        topicSlug,
        topicTitle: item.topicTitle,
        oldAbs: item.abs,
        newAbs: destAbs,
        oldUrls: item.urls,
        newUrl,
      });
    }
  }

  return planned;
}

function moveFiles(planned) {
  for (const p of planned) {
    if (!fs.existsSync(p.oldAbs)) {
      die(`Source image missing on disk: ${p.oldAbs}`);
    }
    ensureDir(path.dirname(p.newAbs));

    if (path.resolve(p.oldAbs) === path.resolve(p.newAbs)) continue;

    if (fs.existsSync(p.newAbs)) {
      die(`Destination already exists: ${p.newAbs}`);
    }

    fs.renameSync(p.oldAbs, p.newAbs);
  }
}

function buildReplacementPairs(planned) {
  const pairs = [];

  for (const p of planned) {
    // For each observed old URL variant, add replacement.
    for (const oldUrlRaw of p.oldUrls) {
      const oldUrl = normalizeUrl(oldUrlRaw);
      if (!oldUrl) continue;

      pairs.push({ from: oldUrl, to: p.newUrl });

      // If oldUrl is /images/..., also replace legacy/relative variants.
      if (oldUrl.startsWith('/images/')) {
        const suffix = oldUrl.slice('/images/'.length);
        pairs.push({ from: `Images/${suffix}`, to: p.newUrl });
        pairs.push({ from: `images/${suffix}`, to: p.newUrl });
        pairs.push({ from: `//images/${suffix}`, to: p.newUrl });
      }
    }
  }

  // Prefer longer matches first.
  pairs.sort((a, b) => b.from.length - a.from.length);
  return pairs;
}

function rewriteRepo(pairs) {
  const files = walkFiles(ROOT);
  const changed = [];

  for (const filePath of files) {
    const rel = path.relative(ROOT, filePath).replace(/\\/g, '/');
    // Avoid rewriting generated outputs (and avoid self-updating mapping).
    if (rel === 'image-audit-all-refs-v2.json') continue;
    if (rel === 'image-audit-detailed-report-v2.json') continue;

    let text;
    try {
      text = fs.readFileSync(filePath, 'utf8');
    } catch {
      continue;
    }

    let next = text;
    for (const r of pairs) {
      if (next.includes(r.from)) next = next.split(r.from).join(r.to);
    }

    if (next !== text) {
      fs.writeFileSync(filePath, next, 'utf8');
      changed.push(filePath);
    }
  }

  return changed;
}

function main() {
  if (!fs.existsSync(AUDIT_ALL_REFS)) {
    die(
      `Missing ${path.basename(AUDIT_ALL_REFS)}. Run: node audit-images-v2.cjs`
    );
  }

  ensureDir(OUT_DIR);

  const auditAll = readJson(AUDIT_ALL_REFS);
  if (!Array.isArray(auditAll))
    die('image-audit-all-refs-v2.json is not an array');

  const files = buildFileUsage(auditAll);
  if (files.length === 0) {
    console.log(
      '[topic-rename] No existing /images references found to rename.'
    );
    fs.writeFileSync(
      OUT_MAP,
      JSON.stringify({ planned: [], changedFiles: [] }, null, 2)
    );
    return;
  }

  const planned = planRenames(files);
  console.log(`[topic-rename] Planned renames: ${planned.length}`);

  moveFiles(planned);

  const pairs = buildReplacementPairs(planned);
  const changedFiles = rewriteRepo(pairs);

  const report = {
    generatedAt: new Date().toISOString(),
    planned: planned.map((p) => ({
      subjectFolder: p.subjectFolder,
      topicTitle: p.topicTitle,
      topicSlug: p.topicSlug,
      oldAbs: p.oldAbs,
      newAbs: p.newAbs,
      oldUrls: p.oldUrls,
      newUrl: p.newUrl,
    })),
    changedFiles,
  };

  fs.writeFileSync(OUT_MAP, JSON.stringify(report, null, 2));

  console.log(`[topic-rename] Renamed ${planned.length} images.`);
  console.log(
    `[topic-rename] Rewrote references in ${changedFiles.length} files.`
  );
  console.log(`[topic-rename] Mapping report: ${path.relative(ROOT, OUT_MAP)}`);
}

main();
