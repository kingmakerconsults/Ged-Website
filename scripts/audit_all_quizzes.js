#!/usr/bin/env node
/**
 * COMPREHENSIVE QUIZ AUDIT TOOL
 *
 * Scans all quiz data sources and generates a detailed quality report.
 * Checks for:
 * - Minimum question count (12+ per quiz)
 * - Challenge tags presence
 * - Question type validity
 * - Rationale completeness
 * - Placeholder/incomplete content
 * - Structural consistency
 */

const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');
const REPORT_DIR = path.join(ROOT, 'reports');

// Quality standards
const STANDARDS = {
  MIN_QUESTIONS_PER_QUIZ: 12,
  REQUIRED_FIELDS: {
    question: ['questionNumber', 'question', 'answerOptions'],
    answerOption: ['text', 'isCorrect'],
  },
  VALID_QUESTION_TYPES: [
    'text',
    'image',
    'multiple-choice-text',
    'multiple-choice-image',
    'multipleChoice',
    'dropdown',
    'fill-in-blank',
    'drag-drop',
    'knowledge',
    'standalone',
    'freeResponse',
    'multiple_choice_single',
    'multiple_select',
    'drag_drop_ordering',
    'short_constructed_response',
  ],
  PLACEHOLDER_PATTERNS: [
    /\bplaceholder\b/i,
    /\blorem\s+ipsum\b/i,
    /\btbd\b/i,
    /\bto\s*be\s*determined\b/i,
    /\bcoming\s*soon\b/i,
    /\bwrite\s+question\b/i,
    /\binsert\s+question\b/i,
    /\bsample\s+question\b/i,
    /\bfill\s+in\s+later\b/i,
    /\bautogenerated?\b/i,
    /\btemplate\b/i,
    /_{3,}/,
    /\[\s*\.\.\.\s*\]/,
    /\{\s*\.\.\.\s*\}/,
  ],
};

const issues = [];
const stats = {
  totalQuizzes: 0,
  totalQuestions: 0,
  bySubject: {},
  bySource: {},
};

function log(msg, level = 'info') {
  const prefix = { info: 'ℹ', warn: '⚠', error: '✗', ok: '✓' }[level] || '';
  console.log(`${prefix} ${msg}`);
}

function addIssue(severity, source, location, message, details = {}) {
  issues.push({ severity, source, location, message, ...details });
}

function checkQuestion(q, quizId, source, index) {
  const loc = `${quizId} Q${index + 1}`;

  // Check required fields
  if (!q.question && !q.questionText && !q.content?.questionText) {
    addIssue('error', source, loc, 'Missing question text');
  }

  if (!q.questionNumber) {
    addIssue('warn', source, loc, 'Missing questionNumber field');
  }

  if (!Array.isArray(q.answerOptions)) {
    addIssue('error', source, loc, 'Missing or invalid answerOptions');
    return;
  }

  // Check answer options
  const correctCount = q.answerOptions.filter((opt) => opt.isCorrect).length;
  if (correctCount === 0) {
    addIssue('error', source, loc, 'No correct answer marked');
  }
  if (correctCount > 1 && q.type !== 'multiple_select') {
    addIssue(
      'warn',
      source,
      loc,
      `Multiple correct answers (${correctCount}) but type is "${q.type}"`
    );
  }

  // Check rationales
  q.answerOptions.forEach((opt, i) => {
    if (!opt.text) {
      addIssue('error', source, loc, `Answer option ${i + 1} missing text`);
    }
    if (!opt.rationale && !opt.isCorrect) {
      addIssue(
        'warn',
        source,
        loc,
        `Answer option ${i + 1} "${opt.text?.slice(
          0,
          30
        )}..." missing rationale`
      );
    }
  });

  // Check for placeholder content
  const textToCheck = [
    q.question || '',
    q.questionText || '',
    q.passage || '',
    q.content?.passage || '',
    ...q.answerOptions.map((o) => o.text || ''),
  ].join(' ');

  for (const pattern of STANDARDS.PLACEHOLDER_PATTERNS) {
    if (pattern.test(textToCheck)) {
      addIssue('error', source, loc, `Contains placeholder text: ${pattern}`);
      break;
    }
  }

  // Check question type
  if (q.type && !STANDARDS.VALID_QUESTION_TYPES.includes(q.type)) {
    addIssue('warn', source, loc, `Unknown question type: "${q.type}"`);
  }

  // Check challenge tags
  if (
    !q.challenge_tags ||
    !Array.isArray(q.challenge_tags) ||
    q.challenge_tags.length === 0
  ) {
    addIssue('warn', source, loc, 'Missing challenge_tags');
  }
}

function auditQuizFile(filePath, source) {
  try {
    let questions;

    if (filePath.endsWith('.json')) {
      const content = fs.readFileSync(filePath, 'utf8');
      const data = JSON.parse(content);
      questions = Array.isArray(data) ? data : data.questions || [];
    } else if (filePath.endsWith('.js')) {
      // Check for merge conflicts first
      const content = fs.readFileSync(filePath, 'utf8');
      if (content.includes('<<<<<<< HEAD')) {
        addIssue(
          'error',
          source,
          path.basename(filePath),
          'File contains unresolved merge conflicts'
        );
        return { quizCount: 0, questionCount: 0 };
      }

      delete require.cache[require.resolve(filePath)];
      questions = require(filePath);
      if (!Array.isArray(questions)) {
        questions = questions.questions || [];
      }
    }

    const quizId = path.basename(filePath, path.extname(filePath));

    if (!Array.isArray(questions)) {
      addIssue('error', source, quizId, 'Could not load questions array');
      return { quizCount: 0, questionCount: 0 };
    }

    // Check minimum question count
    if (questions.length < STANDARDS.MIN_QUESTIONS_PER_QUIZ) {
      addIssue(
        'warn',
        source,
        quizId,
        `Only ${questions.length} questions (min ${STANDARDS.MIN_QUESTIONS_PER_QUIZ})`
      );
    }

    // Audit each question
    questions.forEach((q, i) => checkQuestion(q, quizId, source, i));

    return { quizCount: 1, questionCount: questions.length };
  } catch (e) {
    addIssue(
      'error',
      source,
      path.basename(filePath),
      `Failed to load: ${e.message}`
    );
    return { quizCount: 0, questionCount: 0 };
  }
}

function auditBackendQuizzes() {
  log('Auditing backend/data/quizzes/**/*.js...', 'info');

  const subjects = ['math', 'science', 'social-studies', 'rla'];
  let totalQuizCount = 0;
  let totalQuestionCount = 0;

  subjects.forEach((subject) => {
    const dir = path.join(ROOT, 'backend', 'data', 'quizzes', subject);
    if (!fs.existsSync(dir)) return;

    const files = fs.readdirSync(dir).filter((f) => f.endsWith('.js'));
    files.forEach((file) => {
      const { quizCount, questionCount } = auditQuizFile(
        path.join(dir, file),
        `backend/data/quizzes/${subject}`
      );
      totalQuizCount += quizCount;
      totalQuestionCount += questionCount;
    });
  });

  stats.bySource['backend/data/quizzes'] = {
    quizzes: totalQuizCount,
    questions: totalQuestionCount,
  };
}

function auditFrontendAppData() {
  log('Auditing frontend/app.jsx AppData...', 'info');

  const appJsxPath = path.join(ROOT, 'frontend', 'app.jsx');
  const content = fs.readFileSync(appJsxPath, 'utf8');

  // Find AppData sections for each subject
  const subjects = [
    'Math',
    'Science',
    'Social Studies',
    'Reasoning Through Language Arts \\(RLA\\)',
  ];
  let totalQuizCount = 0;
  let totalQuestionCount = 0;

  subjects.forEach((subject) => {
    const regex = new RegExp(
      `'${subject}': \\{[\\s\\S]*?(?=\\n  '\\w|\\n\\}\\n|$)`,
      'g'
    );
    const matches = content.match(regex);

    if (matches) {
      const questionMatches = matches[0].match(/questionNumber: \d+/g) || [];
      const quizMatches = matches[0].match(/id: '[^']+_quiz\d+'/g) || [];

      totalQuizCount += quizMatches.length;
      totalQuestionCount += questionMatches.length;

      log(
        `  ${subject}: ${quizMatches.length} quizzes, ${questionMatches.length} questions`,
        'info'
      );
    }
  });

  stats.bySource['frontend/app.jsx'] = {
    quizzes: totalQuizCount,
    questions: totalQuestionCount,
  };
}

function auditPublicQuizzes() {
  log('Auditing public/quizzes/*.json...', 'info');

  const dir = path.join(ROOT, 'public', 'quizzes');
  if (!fs.existsSync(dir)) return;

  const files = fs
    .readdirSync(dir)
    .filter((f) => f.endsWith('.json') && !f.includes('.bak'));
  let totalQuizCount = 0;
  let totalQuestionCount = 0;

  files.forEach((file) => {
    const { quizCount, questionCount } = auditQuizFile(
      path.join(dir, file),
      'public/quizzes'
    );
    totalQuizCount += quizCount;
    totalQuestionCount += questionCount;
  });

  stats.bySource['public/quizzes'] = {
    quizzes: totalQuizCount,
    questions: totalQuestionCount,
  };
}

function generateReport() {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const reportPath = path.join(
    REPORT_DIR,
    `comprehensive_quiz_audit_${timestamp}.json`
  );
  const mdPath = path.join(
    REPORT_DIR,
    `comprehensive_quiz_audit_${timestamp}.md`
  );

  if (!fs.existsSync(REPORT_DIR)) {
    fs.mkdirSync(REPORT_DIR, { recursive: true });
  }

  // Generate summary
  const summary = {
    timestamp: new Date().toISOString(),
    totalIssues: issues.length,
    issuesBySeverity: {
      error: issues.filter((i) => i.severity === 'error').length,
      warn: issues.filter((i) => i.severity === 'warn').length,
    },
    sources: stats.bySource,
  };

  // Write JSON report
  fs.writeFileSync(reportPath, JSON.stringify({ summary, issues }, null, 2));

  // Write Markdown report
  let md = `# Comprehensive Quiz Audit Report\n\n`;
  md += `**Generated:** ${summary.timestamp}\n\n`;
  md += `## Summary\n\n`;
  md += `- **Total Issues:** ${summary.totalIssues}\n`;
  md += `- **Errors:** ${summary.issuesBySeverity.error}\n`;
  md += `- **Warnings:** ${summary.issuesBySeverity.warn}\n\n`;

  md += `## Quiz Data Sources\n\n`;
  Object.entries(stats.bySource).forEach(([source, data]) => {
    md += `### ${source}\n`;
    md += `- Quizzes: ${data.quizzes}\n`;
    md += `- Questions: ${data.questions}\n\n`;
  });

  if (issues.length > 0) {
    md += `## Issues\n\n`;
    ['error', 'warn'].forEach((severity) => {
      const filtered = issues.filter((i) => i.severity === severity);
      if (filtered.length > 0) {
        md += `### ${severity.toUpperCase()} (${filtered.length})\n\n`;
        filtered.forEach((issue) => {
          md += `- **${issue.source}** \`${issue.location}\`: ${issue.message}\n`;
        });
        md += `\n`;
      }
    });
  }

  fs.writeFileSync(mdPath, md);

  return { reportPath, mdPath };
}

function main() {
  log('Starting comprehensive quiz audit...', 'info');
  log('', 'info');

  auditBackendQuizzes();
  auditFrontendAppData();
  auditPublicQuizzes();

  const { reportPath, mdPath } = generateReport();

  log('', 'info');
  log('Audit complete!', 'ok');
  log(`JSON Report: ${path.relative(ROOT, reportPath)}`, 'info');
  log(`Markdown Report: ${path.relative(ROOT, mdPath)}`, 'info');
  log('', 'info');
  log(`Total Issues: ${issues.length}`, issues.length > 0 ? 'warn' : 'ok');
  log(
    `  Errors: ${issues.filter((i) => i.severity === 'error').length}`,
    'error'
  );
  log(
    `  Warnings: ${issues.filter((i) => i.severity === 'warn').length}`,
    'warn'
  );
}

main();
