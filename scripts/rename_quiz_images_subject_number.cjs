'use strict';

// Renames/moves quiz-referenced images into subject folders with a consistent scheme
// (e.g., //images/Math/interpreting_bar_graphs_0001.png) and rewrites references across the repo.
//
// Input: image-audit-all-refs-v2.json (generated by audit-images-v2.cjs)
// Output: reports/quiz_image_rename_map.json

const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');
const AUDIT_ALL_REFS = path.join(ROOT, 'image-audit-all-refs-v2.json');
const PUBLIC_IMAGES_ROOT = path.join(ROOT, 'frontend', 'public', 'images');
const OUT_DIR = path.join(ROOT, 'reports');
const OUT_MAP = path.join(OUT_DIR, 'quiz_image_rename_map.json');

const SUBJECT_FOLDER = {
  science: 'Science',
  math: 'Math',
  'social studies': 'Social Studies',
  'reasoning through language arts (rla)': 'RLA',
  rla: 'RLA',
};

const SUBJECT_CODE = {
  Science: 'SCI',
  Math: 'MATH',
  'Social Studies': 'SS',
  RLA: 'RLA',
  Misc: 'MISC',
};

const STOP_PATH_PREFIXES = ['http://', 'https://'];

function die(msg) {
  console.error(msg);
  process.exit(1);
}

function readJson(p) {
  return JSON.parse(fs.readFileSync(p, 'utf8'));
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function normalizeSubjectFromContext(context) {
  // context format: "Subject - Category - Topic - ..."
  const first = String(context || '')
    .split(' - ')[0]
    .trim();
  const key = first.toLowerCase();
  return SUBJECT_FOLDER[key] || 'Misc';
}

function pad4(n) {
  return String(n).padStart(4, '0');
}

function urlToRelativePath(imgUrl) {
  let rel = String(imgUrl || '');
  if (!rel) return null;
  const lower = rel.toLowerCase();
  if (STOP_PATH_PREFIXES.some((p) => lower.startsWith(p))) return null;

  rel = rel.split('?')[0];
  if (rel.startsWith('/')) rel = rel.slice(1);
  rel = decodeURIComponent(rel);
  return rel;
}

function collectQuizImageRefs(auditAll) {
  // Only consider URLs that are local (/images/...) and actually exist on disk.
  const map = new Map();
  for (const item of auditAll) {
    const url = item && item.url;
    if (!url) continue;
    const rel = urlToRelativePath(url);
    if (!rel) continue;

    // Only act on /images/... paths
    if (!rel.toLowerCase().startsWith('images/')) continue;

    // exists flag comes from audit; trust it to avoid renaming stale references
    if (!item.exists) continue;

    if (!map.has(url)) {
      map.set(url, {
        url,
        rel,
        abs: item.path,
        subject: normalizeSubjectFromContext(item.context),
        contexts: new Set([item.context]),
      });
    } else {
      map.get(url).contexts.add(item.context);
    }
  }

  return Array.from(map.values()).map((r) => ({
    ...r,
    contexts: Array.from(r.contexts),
  }));
}

function planRenames(refs) {
  // Deterministic: group by subject folder, sort by original filename
  const bySubject = new Map();
  for (const r of refs) {
    const subj = r.subject || 'Misc';
    if (!bySubject.has(subj)) bySubject.set(subj, []);
    bySubject.get(subj).push(r);
  }

  const planned = [];
  for (const [subjectFolder, items] of bySubject.entries()) {
    items.sort((a, b) => {
      const an = path.basename(a.abs || a.rel || a.url);
      const bn = path.basename(b.abs || b.rel || b.url);
      return an.localeCompare(bn);
    });

    const code = SUBJECT_CODE[subjectFolder] || 'MISC';
    let counter = 1;

    for (const item of items) {
      const ext = path.extname(item.abs || item.rel || item.url) || '.png';
      const newFileName = `${code}_${pad4(counter)}${ext.toLowerCase()}`;
      counter++;

      const newUrl = `/images/${encodeURIComponent(
        subjectFolder
      )}/${newFileName}`
        // keep spaces readable in URLs (server + browser handle them)
        .replace(/%20/g, ' ');

      const destDir = path.join(PUBLIC_IMAGES_ROOT, subjectFolder);
      const destAbs = path.join(destDir, newFileName);

      planned.push({
        oldUrl: item.url,
        oldAbs: item.abs,
        subject: subjectFolder,
        newUrl,
        newAbs: destAbs,
      });
    }
  }

  // Guard against collisions
  const destSet = new Set();
  for (const p of planned) {
    const key = p.newAbs.toLowerCase();
    if (destSet.has(key)) {
      die(`Planned destination collision: ${p.newAbs}`);
    }
    destSet.add(key);
  }

  return planned;
}

function moveFiles(planned) {
  for (const p of planned) {
    if (!fs.existsSync(p.oldAbs)) {
      die(`Source image missing on disk: ${p.oldAbs} (from ${p.oldUrl})`);
    }
    ensureDir(path.dirname(p.newAbs));

    if (path.resolve(p.oldAbs) === path.resolve(p.newAbs)) continue;

    // If destination exists already, fail fast.
    if (fs.existsSync(p.newAbs)) {
      die(`Destination already exists: ${p.newAbs}`);
    }

    fs.renameSync(p.oldAbs, p.newAbs);
  }
}

function walkFiles(dir, fileList = []) {
  if (!fs.existsSync(dir)) return fileList;
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) walkFiles(full, fileList);
    else fileList.push(full);
  }
  return fileList;
}

function rewriteReferences(planned) {
  const replacements = planned
    .map((p) => ({ from: p.oldUrl, to: p.newUrl }))
    // longer first to avoid partial overlaps
    .sort((a, b) => b.from.length - a.from.length);

  const targets = [];
  targets.push(
    ...walkFiles(path.join(ROOT, 'backend', 'data', 'quizzes')).filter((f) =>
      f.endsWith('.js')
    )
  );

  const publicQuizzesDir = path.join(ROOT, 'frontend', 'public', 'quizzes');
  targets.push(
    ...walkFiles(publicQuizzesDir).filter((f) => f.endsWith('.json'))
  );

  const frontendSrcDir = path.join(ROOT, 'frontend', 'src');
  targets.push(
    ...walkFiles(frontendSrcDir).filter((f) => /\.(js|jsx|ts|tsx)$/i.test(f))
  );

  const changed = [];

  for (const filePath of targets) {
    let text;
    try {
      text = fs.readFileSync(filePath, 'utf8');
    } catch {
      continue;
    }

    let next = text;
    for (const r of replacements) {
      if (next.includes(r.from)) {
        next = next.split(r.from).join(r.to);
      }
    }

    if (next !== text) {
      fs.writeFileSync(filePath, next, 'utf8');
      changed.push(filePath);
    }
  }

  return changed;
}

function main() {
  if (!fs.existsSync(AUDIT_ALL_REFS)) {
    die(
      `Missing ${path.basename(
        AUDIT_ALL_REFS
      )}. Run: node audit-images-v2.cjs first.`
    );
  }

  ensureDir(OUT_DIR);

  const auditAll = readJson(AUDIT_ALL_REFS);
  if (!Array.isArray(auditAll))
    die('image-audit-all-refs-v2.json is not an array');

  const refs = collectQuizImageRefs(auditAll);
  if (refs.length === 0) {
    console.log('[rename] No existing /images references found to rename.');
    fs.writeFileSync(
      OUT_MAP,
      JSON.stringify({ planned: [], changedFiles: [] }, null, 2)
    );
    return;
  }

  const planned = planRenames(refs);

  console.log(`[rename] Planned renames: ${planned.length}`);
  moveFiles(planned);

  const changedFiles = rewriteReferences(planned);

  const report = {
    generatedAt: new Date().toISOString(),
    planned,
    changedFiles,
  };

  fs.writeFileSync(OUT_MAP, JSON.stringify(report, null, 2));

  console.log(`[rename] Moved/renamed ${planned.length} images.`);
  console.log(`[rename] Rewrote references in ${changedFiles.length} files.`);
  console.log(`[rename] Mapping report: ${path.relative(ROOT, OUT_MAP)}`);
}

main();
