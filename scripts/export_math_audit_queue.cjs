const fs = require('fs');
const path = require('path');
const { ALL_QUIZZES } = require('../backend/data/quizzes');

const PLACEHOLDER_PATTERNS = [
  /\bplaceholder\b/i,
  /\blorem\s+ipsum\b/i,
  /\btbd\b/i,
  /\bto\s*be\s*determined\b/i,
  /\bcoming\s+soon\b/i,
  /\bwrite\s+question\b/i,
  /\binsert\s+question\b/i,
  /\bsample\s+question\b/i,
  /\bfill\s+in\s+later\b/i,
  /\bautogenerated?\b/i,
  /\btemplate\b/i,
  /\badd\s+your\s+question\b/i,
  /\bquestion\s+here\b/i,
  /\bquestion\s+text\b/i,
  /\btype\s+your\s+question\b/i,
  /\benter\s+question\b/i,
];

const GENERIC_OPTIONS = new Set([
  'all of the above',
  'none of the above',
  'not enough information',
  'cannot be determined',
  "i don't know",
]);

const ISSUE_DEFS = {
  MATH_LATEX_UNBALANCED: 'BLOCKER',
  MATH_LATEX_DOLLAR_DELIMITER: 'MAJOR',
  MATH_LATEX_DOLLAR_UNBALANCED: 'BLOCKER',
  MATH_LATEX_BRACE_UNBALANCED: 'BLOCKER',
  MATH_COMMAND_OUTSIDE_DELIMITERS: 'MAJOR',
  MATH_PLAIN_FRACTION_IN_MATH: 'MAJOR',
  MISSING_PROMPT: 'BLOCKER',
  MISSING_STIMULUS_PASSAGE: 'BLOCKER',
  MISSING_STIMULUS_TABLE: 'BLOCKER',
  MISSING_STIMULUS_IMAGE: 'BLOCKER',
  IMAGE_PATH_INVALID: 'MAJOR',
  TABLE_HTML_BROKEN: 'BLOCKER',
  TABLE_ROW_MISMATCH: 'BLOCKER',
  TABLE_PIPE_MISMATCH: 'BLOCKER',
  FILLER_MISMATCH: 'MAJOR',
};

const normalizeImageUrl = (url) => {
  if (!url) return '';
  let cleaned = String(url).trim();
  cleaned = cleaned.replace(/^https?:\/\/[^/]+/i, '');
  cleaned = cleaned.replace(/\\+/g, '/').replace(/\/+/, '/');
  cleaned = cleaned.replace(/^\/+/, '');
  cleaned = cleaned.replace(/^frontend\/(?:Images|images)\//i, 'images/');
  cleaned = cleaned.replace(/^frontend\/(?:Images|images)/i, 'images');
  cleaned = cleaned.replace(/^(?:Images|images)\//i, 'images/');
  const segments = cleaned.split('/').filter(Boolean);
  if (segments.length === 0) return '';
  const filename = segments[segments.length - 1];
  if (!filename) return '';
  let subjectFolder =
    segments.length >= 3 && segments[0].toLowerCase() === 'images'
      ? segments[1]
      : null;
  if (!subjectFolder) {
    subjectFolder = 'Social Studies';
    for (const segment of segments) {
      const lower = segment.toLowerCase().replace(/[_\s-]+/g, '');
      if (lower.includes('math')) {
        subjectFolder = 'Math';
        break;
      }
      if (lower.includes('science') || lower === 'scince') {
        subjectFolder = 'Science';
        break;
      }
      if (lower.includes('social') || lower.includes('studies')) {
        subjectFolder = 'Social Studies';
        break;
      }
    }
  }
  if (subjectFolder === 'Social_Studies') subjectFolder = 'Social Studies';
  return `/images/${subjectFolder}/${filename}`;
};

function isPlaceholderText(text) {
  if (typeof text !== 'string') return true;
  const trimmed = text.trim();
  if (!trimmed) return true;
  return PLACEHOLDER_PATTERNS.some((pattern) => pattern.test(trimmed));
}

function referencesTableContext(text) {
  if (typeof text !== 'string') return false;
  const lower = text.toLowerCase();
  const ignorePhrases = [
    'table of contents',
    'table of values',
    'times table',
    'multiplication table',
    'table of information',
    'table of data',
    'table for',
    'table at',
    'table set',
    'table setting',
    'dining table',
    'coffee table',
    'tablecloth',
    'table manners',
    'table tennis',
    'table for two',
  ];
  if (ignorePhrases.some((p) => lower.includes(p))) return false;
  const explicit =
    /(table (below|above|shown|shows)|table\s*\d+|see (the )?table|in the table|data table|frequency table|reference table)/i;
  return explicit.test(text);
}

function hasTableMarkup(text) {
  if (typeof text !== 'string') return false;
  if (/<table[\s\S]*?>/i.test(text)) return true;
  const lines = text.split(/\r?\n/).map((line) => line.trim());
  return lines.some((line) => line.includes('|') && line.split('|').length > 2);
}

function extractPipeTableRows(text) {
  if (typeof text !== 'string') return [];
  return text
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.includes('|') && line.split('|').length > 2);
}

function countPipeColumns(line) {
  const trimmed = String(line || '').trim();
  if (!trimmed.includes('|')) return 0;
  let parts = trimmed.split('|');
  if (parts[0].trim() === '') parts = parts.slice(1);
  if (parts[parts.length - 1].trim() === '') parts = parts.slice(0, -1);
  return parts.length;
}

function getHtmlTableRows(html) {
  if (typeof html !== 'string') return [];
  const tables = html.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi) || [];
  return tables.map((table) => {
    const rows = [];
    const rowMatches = table.match(/<tr[\s\S]*?>[\s\S]*?<\/tr>/gi) || [];
    rowMatches.forEach((row) => {
      const cells = row.match(/<t[dh][\s\S]*?>/gi) || [];
      rows.push(cells.length);
    });
    return rows;
  });
}

function hasUnbalancedDelimiters(text, openToken, closeToken) {
  if (typeof text !== 'string') return false;
  const tokens = [];
  const regex = new RegExp(`(${openToken}|${closeToken})`, 'g');
  let match;
  while ((match = regex.exec(text))) {
    tokens.push({ value: match[0] });
  }
  let balance = 0;
  for (const t of tokens) {
    if (t.value === openToken) balance++;
    if (t.value === closeToken) balance--;
    if (balance < 0) return true;
  }
  return balance !== 0;
}

function findUnescapedDollarCount(text) {
  if (typeof text !== 'string') return 0;
  let count = 0;
  for (let i = 0; i < text.length; i++) {
    if (text[i] === '$' && text[i - 1] !== '\\') {
      let j = i + 1;
      while (j < text.length && text[j] === ' ') j++;
      if (j < text.length && /\d/.test(text[j])) {
        continue;
      }
      if (text[i + 1] === '$') {
        i++;
        continue;
      }
      count++;
    }
  }
  return count;
}

function hasUnbalancedBraces(latex) {
  if (typeof latex !== 'string') return false;
  let balance = 0;
  for (let i = 0; i < latex.length; i++) {
    const ch = latex[i];
    if (ch === '{' && latex[i - 1] !== '\\') balance++;
    if (ch === '}' && latex[i - 1] !== '\\') balance--;
    if (balance < 0) return true;
  }
  return balance !== 0;
}

function containsLatexCommandOutsideMath(text) {
  if (typeof text !== 'string') return false;
  const commands =
    /(\\frac|\\sqrt|\\times|\\cdot|\\pi|\\theta|\\left|\\right|\\begin|\\end|\\sum|\\int|\\approx|\\neq|\\leq|\\geq)/g;
  return commands.test(text);
}

function extractMathSegments(text) {
  if (typeof text !== 'string' || text.length === 0) {
    return [];
  }
  const segments = [];
  let buffer = '';
  const flushText = () => {
    if (buffer) {
      segments.push({ type: 'text', value: buffer });
      buffer = '';
    }
  };

  let i = 0;
  while (i < text.length) {
    if (text[i] === '\\' && text[i + 1] === '$') {
      buffer += '$';
      i += 2;
      continue;
    }
    if (text[i] === '\\' && text[i + 1] === '(') {
      const close = text.indexOf('\\)', i + 2);
      if (close !== -1) {
        flushText();
        const raw = text.slice(i, close + 2);
        const body = text.slice(i + 2, close);
        segments.push({ type: 'math', raw, value: body, displayMode: false });
        i = close + 2;
        continue;
      }
    }
    if (text[i] === '\\' && text[i + 1] === '[') {
      const close = text.indexOf('\\]', i + 2);
      if (close !== -1) {
        flushText();
        const raw = text.slice(i, close + 2);
        const body = text.slice(i + 2, close);
        segments.push({ type: 'math', raw, value: body, displayMode: true });
        i = close + 2;
        continue;
      }
    }
    if (text[i] === '$') {
      if (text[i + 1] === '$') {
        const close = text.indexOf('$$', i + 2);
        if (close !== -1) {
          flushText();
          const raw = text.slice(i, close + 2);
          const body = text.slice(i + 2, close);
          segments.push({ type: 'math', raw, value: body, displayMode: true });
          i = close + 2;
          continue;
        }
      } else {
        const close = text.indexOf('$', i + 1);
        if (close !== -1) {
          flushText();
          const raw = text.slice(i, close + 1);
          const body = text.slice(i + 1, close);
          segments.push({ type: 'math', raw, value: body, displayMode: false });
          i = close + 1;
          continue;
        }
      }
    }
    buffer += text[i];
    i += 1;
  }
  flushText();
  return segments;
}

function normalizeText(value) {
  if (typeof value !== 'string') return '';
  return value
    .toLowerCase()
    .replace(/<[^>]+>/g, ' ')
    .replace(/[^a-z0-9\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function tokenize(value) {
  if (!value) return [];
  return normalizeText(value).split(' ').filter(Boolean);
}

function countNumericTokens(value) {
  if (typeof value !== 'string') return 0;
  return (value.match(/\d+(?:[.,]\d+)?/g) || []).length;
}

function isVocabularyContext(question, questionText) {
  const subject = String(question?.subject || '').toLowerCase();
  if (!subject.includes('language')) return false;
  const category = String(question?.category || '').toLowerCase();
  const quizTitle = String(question?.quizTitle || '').toLowerCase();
  if (category.includes('vocabulary') || quizTitle.includes('vocabulary')) {
    return true;
  }
  const text = String(questionText || '').toLowerCase();
  return /\b(what does|most nearly mean|meaning of|definition of|word|phrase)\b/.test(
    text
  );
}

function getQuestionText(question) {
  if (!question || typeof question !== 'object') return '';
  const content = question?.content || {};
  return (
    question?.question ||
    question?.questionText ||
    content.questionText ||
    content.question ||
    ''
  );
}

function getQuestionPassage(question) {
  const content = question?.content || {};
  return question?.passage || content.passage || '';
}

function getQuestionImage(question) {
  const content = question?.content || {};
  return (
    question?.image ||
    question?.imageUrl ||
    question?.imageURL ||
    question?.graphic ||
    question?.stimulusImage?.src ||
    question?.stimulusImage ||
    content.imageURL ||
    content.image ||
    (typeof question?.stimulus === 'object'
      ? question?.stimulus?.image || question?.stimulus?.src
      : null) ||
    null
  );
}

function getFieldList(question) {
  const fields = [
    { name: 'question', value: getQuestionText(question) },
    { name: 'passage', value: getQuestionPassage(question) },
  ];

  const answerOptions = Array.isArray(question?.answerOptions)
    ? question.answerOptions
    : [];
  answerOptions.forEach((opt, idx) => {
    const text = typeof opt === 'object' ? opt.text : opt;
    const rationale = typeof opt === 'object' ? opt.rationale : undefined;
    fields.push({ name: `answer[${idx}].text`, value: text });
    if (typeof rationale === 'string') {
      fields.push({ name: `answer[${idx}].rationale`, value: rationale });
    }
  });

  return fields;
}

function buildAuditIssues(question) {
  const issues = [];
  const fields = getFieldList(question);
  const questionText = getQuestionText(question);
  const passageText = getQuestionPassage(question);
  const imageRef = getQuestionImage(question);

  const addIssue = (code, context = {}) => {
    issues.push({
      code,
      severity: ISSUE_DEFS[code] || 'MAJOR',
      ...context,
    });
  };

  if (isPlaceholderText(questionText)) {
    addIssue('MISSING_PROMPT', { field: 'question', raw: questionText });
  }

  if (
    (question?.passage != null || question?.content?.passage != null) &&
    isPlaceholderText(passageText)
  ) {
    addIssue('MISSING_STIMULUS_PASSAGE', {
      field: 'passage',
      raw: passageText,
    });
  }

  if (
    (question?.stimulusImage ||
      question?.image ||
      question?.imageUrl ||
      question?.imageURL ||
      question?.graphic ||
      question?.content?.image ||
      question?.content?.imageURL) &&
    !imageRef
  ) {
    addIssue('MISSING_STIMULUS_IMAGE', {
      field: 'image',
      raw: String(imageRef || ''),
    });
  }

  if (typeof imageRef === 'string' && imageRef.trim()) {
    const normalized = normalizeImageUrl(imageRef);
    if (!normalized || /undefined|null/i.test(normalized)) {
      addIssue('IMAGE_PATH_INVALID', {
        field: 'image',
        raw: imageRef,
      });
    } else if (
      !/(?:\.png|\.jpe?g|\.gif|\.svg|\.webp)(\?|#|$)/i.test(normalized) &&
      !/^data:image\//i.test(normalized)
    ) {
      addIssue('IMAGE_PATH_INVALID', {
        field: 'image',
        raw: imageRef,
      });
    }
  }

  if (
    /<img\b/i.test(passageText || '') &&
    !/src\s*=\s*['"]/i.test(passageText || '')
  ) {
    addIssue('MISSING_STIMULUS_IMAGE', {
      field: 'passage',
      raw: passageText,
    });
  }

  const combinedText = [questionText, passageText].filter(Boolean).join('\n');

  const referencesTable =
    referencesTableContext(questionText) || referencesTableContext(passageText);
  const hasTable = hasTableMarkup(combinedText);
  if (referencesTable && !hasTable) {
    addIssue('MISSING_STIMULUS_TABLE', {
      field: 'question/passage',
      raw: combinedText,
    });
  }

  if (typeof combinedText === 'string' && combinedText.includes('<table')) {
    if (!combinedText.includes('</table>')) {
      addIssue('TABLE_HTML_BROKEN', {
        field: 'question/passage',
        raw: combinedText,
      });
    }
    const rowsPerTable = getHtmlTableRows(combinedText);
    rowsPerTable.forEach((rows) => {
      if (rows.length > 1) {
        const expected = rows[0];
        if (rows.some((c) => c !== expected)) {
          addIssue('TABLE_ROW_MISMATCH', {
            field: 'question/passage',
            raw: combinedText,
          });
        }
      }
    });
  }

  const pipeRows = extractPipeTableRows(combinedText);
  if (pipeRows.length >= 2) {
    const baseCols = countPipeColumns(pipeRows[0]);
    if (baseCols > 1) {
      const mismatch = pipeRows.some(
        (row) => countPipeColumns(row) !== baseCols
      );
      if (mismatch) {
        addIssue('TABLE_PIPE_MISMATCH', {
          field: 'question/passage',
          raw: combinedText,
        });
      }
    }
  }

  fields.forEach((field) => {
    const text = field.value;
    if (typeof text !== 'string' || !text.trim()) return;

    if (
      hasUnbalancedDelimiters(text, '\\(', '\\)') ||
      hasUnbalancedDelimiters(text, '\\[', '\\]')
    ) {
      addIssue('MATH_LATEX_UNBALANCED', {
        field: field.name,
        raw: text,
      });
    }

    const dollarCount = findUnescapedDollarCount(text);
    if (dollarCount % 2 !== 0) {
      addIssue('MATH_LATEX_DOLLAR_UNBALANCED', {
        field: field.name,
        raw: text,
      });
    }

    const segments = extractMathSegments(text);
    const hasDollarSegments = segments.some((seg) => seg.raw?.startsWith('$'));
    if (hasDollarSegments) {
      addIssue('MATH_LATEX_DOLLAR_DELIMITER', {
        field: field.name,
        raw: text,
      });
    }

    const textOutsideMath = segments.length
      ? segments
          .filter((seg) => seg.type !== 'math')
          .map((seg) => seg.value)
          .join(' ')
      : text;

    if (containsLatexCommandOutsideMath(textOutsideMath)) {
      addIssue('MATH_COMMAND_OUTSIDE_DELIMITERS', {
        field: field.name,
        raw: textOutsideMath,
      });
    }

    segments
      .filter((seg) => seg.type === 'math')
      .forEach((seg) => {
        if (hasUnbalancedBraces(seg.value)) {
          addIssue('MATH_LATEX_BRACE_UNBALANCED', {
            field: field.name,
            raw: seg.value,
            math: seg.value,
          });
        }
        if (/\b\d+\/\d+\b/.test(seg.value) && !/\\frac\b/.test(seg.value)) {
          addIssue('MATH_PLAIN_FRACTION_IN_MATH', {
            field: field.name,
            raw: seg.value,
            math: seg.value,
          });
        }
      });
  });

  const answerOptions = Array.isArray(question?.answerOptions)
    ? question.answerOptions
    : [];
  const questionTokens = tokenize(questionText);
  const hasMathDelimiters = /\\\(|\\\)|\\\[|\\\]|\$\$?|\\frac|\\sqrt/.test(
    questionText
  );
  const questionNumericTokens = countNumericTokens(questionText);

  const answerTexts = answerOptions.map((opt) =>
    normalizeText(typeof opt === 'object' ? opt.text : opt)
  );
  const answerTokens = answerTexts.map((t) => tokenize(t));
  const answerNumericCounts = answerTexts.map(countNumericTokens);
  const numericAnswers = answerNumericCounts.filter((n) => n > 0).length;
  const vocabContext = isVocabularyContext(question, questionText);

  if (
    questionTokens.length >= 4 &&
    !hasMathDelimiters &&
    !(questionNumericTokens > 0 && numericAnswers >= 2) &&
    answerTokens.length >= 2 &&
    !vocabContext
  ) {
    const overlaps = answerTokens.map((tokens) => {
      if (!tokens.length) return 0;
      const overlap = tokens.filter((t) => questionTokens.includes(t)).length;
      return overlap / tokens.length;
    });
    const lowOverlap = overlaps.every((ratio) => ratio < 0.1);
    const genericCount = answerTexts.filter((t) =>
      GENERIC_OPTIONS.has(t.toLowerCase())
    ).length;
    const shortCount = answerTokens.filter((t) => t.length <= 2).length;

    if (
      lowOverlap &&
      (genericCount >= 2 || shortCount >= answerTokens.length)
    ) {
      addIssue('FILLER_MISMATCH', {
        field: 'answerOptions',
        raw: answerTexts.join(' | '),
      });
    }
  }

  return issues;
}

function rebuildFromCatalog(catalog) {
  if (!catalog || typeof catalog !== 'object') return [];
  let list = [];

  const addQuizQuestions = (subject, categoryLabel, quiz, quizIndex) => {
    const questionsSources = [];
    if (Array.isArray(quiz?.questions)) questionsSources.push(quiz.questions);
    if (Array.isArray(quiz?.items)) questionsSources.push(quiz.items);
    if (Array.isArray(quiz?.questionBank?.questions))
      questionsSources.push(quiz.questionBank.questions);

    const merged = questionsSources.flat();
    if (!Array.isArray(merged) || merged.length === 0) return;

    merged.forEach((q, questionIndex) => {
      const qObj = typeof q === 'object' ? q : { questionText: String(q) };
      list.push({
        id: `${subject}-${categoryLabel}-${quizIndex}-${questionIndex}`,
        subject,
        category: categoryLabel || quiz.category || 'General',
        quizTitle: quiz.title || `Quiz ${quizIndex + 1}`,
        source: 'premade',
        ...qObj,
      });
    });
  };

  Object.entries(catalog).forEach(([subject, subjData]) => {
    if (Array.isArray(subjData)) {
      subjData.forEach((quiz, quizIndex) => {
        addQuizQuestions(subject, quiz.category || 'General', quiz, quizIndex);
      });
      return;
    }

    if (Array.isArray(subjData?.quizzes)) {
      subjData.quizzes.forEach((quiz, quizIndex) => {
        addQuizQuestions(subject, quiz.category || 'General', quiz, quizIndex);
      });
    }

    const categories = subjData?.categories || {};
    Object.entries(categories).forEach(([categoryName, catData]) => {
      catData?.quizzes?.forEach((quiz, quizIndex) => {
        addQuizQuestions(subject, categoryName, quiz, quizIndex);
      });

      catData?.topics?.forEach((topic, topicIndex) => {
        if (Array.isArray(topic?.quizzes)) {
          topic.quizzes.forEach((quiz, quizIndex) => {
            addQuizQuestions(
              subject,
              topic.title || categoryName,
              quiz,
              quizIndex
            );
          });
        }

        if (Array.isArray(topic?.questions)) {
          topic.questions.forEach((q, questionIndex) => {
            list.push({
              id: `${subject}-${categoryName}-topic-${topicIndex}-${questionIndex}`,
              subject,
              category: topic.title || categoryName,
              quizTitle: topic.title || `Topic ${topicIndex + 1}`,
              source: 'premade',
              ...q,
            });
          });
        }
      });
    });
  });

  return list;
}

function main() {
  const allQuestions = rebuildFromCatalog(ALL_QUIZZES);
  const mathQuestions = allQuestions.filter(
    (q) => String(q.subject || '').toLowerCase() === 'math'
  );

  const flagged = [];
  mathQuestions.forEach((q) => {
    const issues = buildAuditIssues(q);
    if (issues.length > 0) {
      flagged.push({
        id: q.id,
        category: q.category || 'General',
        quizTitle: q.quizTitle || 'Quiz',
        question: getQuestionText(q),
        passage: getQuestionPassage(q),
        issues,
      });
    }
  });

  const out = {
    totalQuestions: mathQuestions.length,
    flaggedQuestions: flagged.length,
    generatedAt: new Date().toISOString(),
    issuesByCode: flagged.reduce((acc, q) => {
      q.issues.forEach((issue) => {
        acc[issue.code] = (acc[issue.code] || 0) + 1;
      });
      return acc;
    }, {}),
    flagged,
  };

  const outPath = path.join(
    __dirname,
    '..',
    'reports',
    'math_audit_queue.json'
  );
  fs.writeFileSync(outPath, JSON.stringify(out, null, 2));
  console.log(`Wrote ${flagged.length} flagged math questions to ${outPath}`);
}

main();
